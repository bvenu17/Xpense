{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst stream_1 = require(\"stream\");\n\nconst constants_1 = require(\"./constants\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\n\n\nfunction callErrorFromStatus(status) {\n  const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n  return Object.assign(new Error(message), status);\n}\n\nexports.callErrorFromStatus = callErrorFromStatus;\n\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n  constructor() {\n    super();\n  }\n\n  cancel() {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    var _a, _b;\n\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n  }\n\n}\n\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\n\nclass ClientReadableStreamImpl extends stream_1.Readable {\n  constructor(deserialize) {\n    super({\n      objectMode: true\n    });\n    this.deserialize = deserialize;\n  }\n\n  cancel() {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    var _a, _b;\n\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n  }\n\n  _read(_size) {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n  }\n\n}\n\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\n\nclass ClientWritableStreamImpl extends stream_1.Writable {\n  constructor(serialize) {\n    super({\n      objectMode: true\n    });\n    this.serialize = serialize;\n  }\n\n  cancel() {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    var _a, _b;\n\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n  }\n\n  _write(chunk, encoding, cb) {\n    var _a;\n\n    const context = {\n      callback: cb\n    };\n    const flags = Number(encoding);\n\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n  }\n\n  _final(cb) {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n    cb();\n  }\n\n}\n\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\n\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n  constructor(serialize, deserialize) {\n    super({\n      objectMode: true\n    });\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n  }\n\n  cancel() {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n  }\n\n  getPeer() {\n    var _a, _b;\n\n    return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n  }\n\n  _read(_size) {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n  }\n\n  _write(chunk, encoding, cb) {\n    var _a;\n\n    const context = {\n      callback: cb\n    };\n    const flags = Number(encoding);\n\n    if (!Number.isNaN(flags)) {\n      context.flags = flags;\n    }\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n  }\n\n  _final(cb) {\n    var _a;\n\n    (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n    cb();\n  }\n\n}\n\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;","map":{"version":3,"sources":["../../src/call.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst stream_1 = require(\"stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nfunction callErrorFromStatus(status) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    return Object.assign(new Error(message), status);\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor() {\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize) {\n        super({ objectMode: true });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : '';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\n//# sourceMappingURL=call.js.map"]},"metadata":{},"sourceType":"script"}