{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst metadata_1 = require(\"./metadata\");\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\n\n\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n\n}\n\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\n\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n\n}\n\nexports.ListenerBuilder = ListenerBuilder;\n\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n\n}\n\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\n\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\n\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\n\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n\n    this.nextCall = nextCall;\n    /**\n     * Indicates that a message has been passed to the listener's onReceiveMessage\n     * method it has not been passed to the corresponding next callback\n     */\n\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n\n    this.pendingHalfClose = false;\n\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n\n      let finalInterceptingListener;\n\n      if (call_stream_1.isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n\n      this.nextCall.start(md, finalInterceptingListener);\n    });\n  } // tslint:disable-next-line no-any\n\n\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      this.nextCall.sendMessageWithContext(context, finalMessage);\n\n      if (this.pendingHalfClose) {\n        this.nextCall.halfClose();\n      }\n    });\n  } // tslint:disable-next-line no-any\n\n\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n\n  startRead() {\n    this.nextCall.startRead();\n  }\n\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n\n  setCredentials(credentials) {\n    this.nextCall.setCredentials(credentials);\n  }\n\n}\n\nexports.InterceptingCall = InterceptingCall;\n\nfunction getCall(channel, path, options) {\n  let deadline;\n  let host;\n  const parent = null;\n  let propagateFlags;\n  let credentials;\n\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    propagateFlags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\n\n\nclass BaseInterceptingCall {\n  // tslint:disable-next-line no-any\n  constructor(call, methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  setCredentials(credentials) {\n    this.call.setCredentials(credentials);\n  } // tslint:disable-next-line no-any\n\n\n  sendMessageWithContext(context, message) {\n    let serialized;\n\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n      this.call.sendMessageWithContext(context, serialized);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, 'Serialization failure');\n    }\n  } // tslint:disable-next-line no-any\n\n\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a; // tslint:disable-next-line no-any\n\n\n        let deserialized;\n\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: 'Failed to parse server response',\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n        }\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n\n  startRead() {\n    this.call.startRead();\n  }\n\n  halfClose() {\n    this.call.halfClose();\n  }\n\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\n\n\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // tslint:disable-next-line no-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n\n  start(metadata, listener) {\n    var _a, _b;\n\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // tslint:disable-next-line no-any\n      onReceiveMessage: message => {\n        var _a;\n\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\n\n\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {} // tslint:disable-next-line no-any\n\n\nfunction getBottomInterceptingCall(channel, options, methodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n} // tslint:disable-next-line no-any\n\n\nfunction getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n\n  let interceptors = []; // Interceptors passed to the call override interceptors passed to the client constructor\n\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor); // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor); // Filter out falsy values when providers return nothing\n  }\n\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\n\nexports.getInterceptingCall = getInterceptingCall;","map":{"version":3,"sources":["../../src/client-interceptors.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;AAiBA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAkBA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAMA;;;;;;AAIA,MAAa,6BAAb,SAAmD,KAAnD,CAAwD;AACtD,EAAA,WAAA,CAAY,OAAZ,EAA2B;AACzB,UAAM,OAAN;AACA,SAAK,IAAL,GAAY,+BAAZ;AACA,IAAA,KAAK,CAAC,iBAAN,CAAwB,IAAxB,EAA8B,6BAA9B;AACD;;AALqD;;AAAxD,OAAA,CAAA,6BAAA,GAAA,6BAAA;;AA4CA,MAAa,eAAb,CAA4B;AAA5B,EAAA,WAAA,GAAA;AACU,SAAA,QAAA,GAAyC,SAAzC;AACA,SAAA,OAAA,GAAuC,SAAvC;AACA,SAAA,MAAA,GAAqC,SAArC;AAwBT;;AAtBC,EAAA,qBAAqB,CAAC,iBAAD,EAAoC;AACvD,SAAK,QAAL,GAAgB,iBAAhB;AACA,WAAO,IAAP;AACD;;AAED,EAAA,oBAAoB,CAAC,gBAAD,EAAkC;AACpD,SAAK,OAAL,GAAe,gBAAf;AACA,WAAO,IAAP;AACD;;AAED,EAAA,mBAAmB,CAAC,eAAD,EAAgC;AACjD,SAAK,MAAL,GAAc,eAAd;AACA,WAAO,IAAP;AACD;;AAED,EAAA,KAAK,GAAA;AACH,WAAO;AACL,MAAA,iBAAiB,EAAE,KAAK,QADnB;AAEL,MAAA,gBAAgB,EAAE,KAAK,OAFlB;AAGL,MAAA,eAAe,EAAE,KAAK;AAHjB,KAAP;AAKD;;AA1ByB;;AAA5B,OAAA,CAAA,eAAA,GAAA,eAAA;;AA6BA,MAAa,gBAAb,CAA6B;AAA7B,EAAA,WAAA,GAAA;AACU,SAAA,KAAA,GAAuC,SAAvC;AACA,SAAA,OAAA,GAAwC,SAAxC;AACA,SAAA,SAAA,GAAwC,SAAxC;AACA,SAAA,MAAA,GAAsC,SAAtC;AA8BT;;AA5BC,EAAA,SAAS,CAAC,KAAD,EAAyB;AAChC,SAAK,KAAL,GAAa,KAAb;AACA,WAAO,IAAP;AACD;;AAED,EAAA,eAAe,CAAC,WAAD,EAA8B;AAC3C,SAAK,OAAL,GAAe,WAAf;AACA,WAAO,IAAP;AACD;;AAED,EAAA,aAAa,CAAC,SAAD,EAA0B;AACrC,SAAK,SAAL,GAAiB,SAAjB;AACA,WAAO,IAAP;AACD;;AAED,EAAA,UAAU,CAAC,MAAD,EAAwB;AAChC,SAAK,MAAL,GAAc,MAAd;AACA,WAAO,IAAP;AACD;;AAED,EAAA,KAAK,GAAA;AACH,WAAO;AACL,MAAA,KAAK,EAAE,KAAK,KADP;AAEL,MAAA,WAAW,EAAE,KAAK,OAFb;AAGL,MAAA,SAAS,EAAE,KAAK,SAHX;AAIL,MAAA,MAAM,EAAE,KAAK;AAJR,KAAP;AAMD;;AAjC0B;;AAA7B,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAoCA;;;;;AAIA,MAAM,eAAe,GAAiB;AACpC,EAAA,iBAAiB,EAAE,CAAC,QAAD,EAAW,IAAX,KAAmB;AACpC,IAAA,IAAI,CAAC,QAAD,CAAJ;AACD,GAHmC;AAIpC,EAAA,gBAAgB,EAAE,CAAC,OAAD,EAAU,IAAV,KAAkB;AAClC,IAAA,IAAI,CAAC,OAAD,CAAJ;AACD,GANmC;AAOpC,EAAA,eAAe,EAAE,CAAC,MAAD,EAAS,IAAT,KAAiB;AAChC,IAAA,IAAI,CAAC,MAAD,CAAJ;AACD;AATmC,CAAtC;AAYA;;;;;AAIA,MAAM,gBAAgB,GAAkB;AACtC,EAAA,KAAK,EAAE,CAAC,QAAD,EAAW,QAAX,EAAqB,IAArB,KAA6B;AAClC,IAAA,IAAI,CAAC,QAAD,EAAW,QAAX,CAAJ;AACD,GAHqC;AAItC,EAAA,WAAW,EAAE,CAAC,OAAD,EAAU,IAAV,KAAkB;AAC7B,IAAA,IAAI,CAAC,OAAD,CAAJ;AACD,GANqC;AAOtC,EAAA,SAAS,EAAE,IAAI,IAAG;AAChB,IAAA,IAAI;AACL,GATqC;AAUtC,EAAA,MAAM,EAAE,IAAI,IAAG;AACb,IAAA,IAAI;AACL;AAZqC,CAAxC;;AAkCA,MAAa,gBAAb,CAA6B;AAe3B,EAAA,WAAA,CACU,QADV,EAEE,SAFF,EAEuB;;;AADb,SAAA,QAAA,GAAA,QAAA;AAXV;;;;;AAIQ,SAAA,iBAAA,GAAoB,KAApB;AACR;;;;;AAIQ,SAAA,gBAAA,GAAmB,KAAnB;;AAKN,QAAI,SAAJ,EAAe;AACb,WAAK,SAAL,GAAiB;AACf,QAAA,KAAK,EAAA,CAAA,EAAA,GAAE,SAAS,CAAC,KAAZ,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,gBAAgB,CAAC,KAD5B;AAEf,QAAA,WAAW,EAAA,CAAA,EAAA,GAAE,SAAS,CAAC,WAAZ,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,EAAvB,GAA2B,gBAAgB,CAAC,WAFxC;AAGf,QAAA,SAAS,EAAA,CAAA,EAAA,GAAE,SAAS,CAAC,SAAZ,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,EAArB,GAAyB,gBAAgB,CAAC,SAHpC;AAIf,QAAA,MAAM,EAAA,CAAA,EAAA,GAAE,SAAS,CAAC,MAAZ,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,EAAlB,GAAsB,gBAAgB,CAAC;AAJ9B,OAAjB;AAMD,KAPD,MAOO;AACL,WAAK,SAAL,GAAiB,gBAAjB;AACD;AACF;;AAED,EAAA,gBAAgB,CAAC,MAAD,EAAiB,OAAjB,EAAgC;AAC9C,SAAK,SAAL,CAAe,MAAf,CAAsB,MAAK;AACzB,WAAK,QAAL,CAAc,gBAAd,CAA+B,MAA/B,EAAuC,OAAvC;AACD,KAFD;AAGD;;AAED,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,QAAL,CAAc,OAAd,EAAP;AACD;;AACD,EAAA,KAAK,CACH,QADG,EAEH,oBAFG,EAEiD;;;AAEpD,UAAM,wBAAwB,GAAyB;AACrD,MAAA,iBAAiB,EAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GACf,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,iBADP,MACwB,IADxB,IACwB,EAAA,KAAA,KAAA,CADxB,GACwB,KAAA,CADxB,GACwB,EAAA,CAAE,IAAF,CAAO,oBAAP,CADxB,MACmD,IADnD,IACmD,EAAA,KAAA,KAAA,CADnD,GACmD,EADnD,GAEd,QAAQ,IAAG,CAAG,CAHoC;AAIrD,MAAA,gBAAgB,EAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GACd,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,gBADR,MACwB,IADxB,IACwB,EAAA,KAAA,KAAA,CADxB,GACwB,KAAA,CADxB,GACwB,EAAA,CAAE,IAAF,CAAO,oBAAP,CADxB,MACmD,IADnD,IACmD,EAAA,KAAA,KAAA,CADnD,GACmD,EADnD,GAEb,OAAO,IAAG,CAAG,CANqC;AAOrD,MAAA,eAAe,EAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GACb,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,eADT,MACwB,IADxB,IACwB,EAAA,KAAA,KAAA,CADxB,GACwB,KAAA,CADxB,GACwB,EAAA,CAAE,IAAF,CAAO,oBAAP,CADxB,MACmD,IADnD,IACmD,EAAA,KAAA,KAAA,CADnD,GACmD,EADnD,GAEZ,MAAM,IAAG,CAAG;AATsC,KAAvD;AAWA,SAAK,SAAL,CAAe,KAAf,CAAqB,QAArB,EAA+B,wBAA/B,EAAyD,CAAC,EAAD,EAAK,QAAL,KAAiB;;;AACxE,UAAI,yBAAJ;;AACA,UAAI,aAAA,CAAA,sBAAA,CAAuB,QAAvB,CAAJ,EAAsC;AACpC,QAAA,yBAAyB,GAAG,QAA5B;AACD,OAFD,MAEO;AACL,cAAM,YAAY,GAAiB;AACjC,UAAA,iBAAiB,EAAA,CAAA,EAAA,GACf,QAAQ,CAAC,iBADM,MACW,IADX,IACW,EAAA,KAAA,KAAA,CADX,GACW,EADX,GACe,eAAe,CAAC,iBAFf;AAGjC,UAAA,gBAAgB,EAAA,CAAA,EAAA,GACd,QAAQ,CAAC,gBADK,MACW,IADX,IACW,EAAA,KAAA,KAAA,CADX,GACW,EADX,GACe,eAAe,CAAC,gBAJd;AAKjC,UAAA,eAAe,EAAA,CAAA,EAAA,GACb,QAAQ,CAAC,eADI,MACW,IADX,IACW,EAAA,KAAA,KAAA,CADX,GACW,EADX,GACe,eAAe,CAAC;AANb,SAAnC;AAQA,QAAA,yBAAyB,GAAG,IAAI,aAAA,CAAA,wBAAJ,CAC1B,YAD0B,EAE1B,wBAF0B,CAA5B;AAID;;AACD,WAAK,QAAL,CAAc,KAAd,CAAoB,EAApB,EAAwB,yBAAxB;AACD,KAnBD;AAoBD,GA3E0B,CA4E3B;;;AACA,EAAA,sBAAsB,CAAC,OAAD,EAA0B,OAA1B,EAAsC;AAC1D,SAAK,iBAAL,GAAyB,IAAzB;AACA,SAAK,SAAL,CAAe,WAAf,CAA2B,OAA3B,EAAoC,YAAY,IAAG;AACjD,WAAK,iBAAL,GAAyB,KAAzB;AACA,WAAK,QAAL,CAAc,sBAAd,CAAqC,OAArC,EAA8C,YAA9C;;AACA,UAAI,KAAK,gBAAT,EAA2B;AACzB,aAAK,QAAL,CAAc,SAAd;AACD;AACF,KAND;AAOD,GAtF0B,CAuF3B;;;AACA,EAAA,WAAW,CAAC,OAAD,EAAa;AACtB,SAAK,sBAAL,CAA4B,EAA5B,EAAgC,OAAhC;AACD;;AACD,EAAA,SAAS,GAAA;AACP,SAAK,QAAL,CAAc,SAAd;AACD;;AACD,EAAA,SAAS,GAAA;AACP,SAAK,SAAL,CAAe,SAAf,CAAyB,MAAK;AAC5B,UAAI,KAAK,iBAAT,EAA4B;AAC1B,aAAK,gBAAL,GAAwB,IAAxB;AACD,OAFD,MAEO;AACL,aAAK,QAAL,CAAc,SAAd;AACD;AACF,KAND;AAOD;;AACD,EAAA,cAAc,CAAC,WAAD,EAA6B;AACzC,SAAK,QAAL,CAAc,cAAd,CAA6B,WAA7B;AACD;;AAzG0B;;AAA7B,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AA4GA,SAAS,OAAT,CAAiB,OAAjB,EAAmC,IAAnC,EAAiD,OAAjD,EAAqE;AACnE,MAAI,QAAJ;AACA,MAAI,IAAJ;AACA,QAAM,MAAM,GAAG,IAAf;AACA,MAAI,cAAJ;AACA,MAAI,WAAJ;;AACA,MAAI,OAAJ,EAAa;AACX,IAAA,QAAQ,GAAG,OAAO,CAAC,QAAnB;AACA,IAAA,IAAI,GAAG,OAAO,CAAC,IAAf;AAEA,IAAA,cAAc,GAAG,OAAO,CAAC,eAAzB;AACA,IAAA,WAAW,GAAG,OAAO,CAAC,WAAtB;AACD;;AACD,MAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,IAAA,QAAQ,GAAG,QAAX;AACD;;AACD,QAAM,IAAI,GAAG,OAAO,CAAC,UAAR,CAAmB,IAAnB,EAAyB,QAAzB,EAAmC,IAAnC,EAAyC,MAAzC,EAAiD,cAAjD,CAAb;;AACA,MAAI,WAAJ,EAAiB;AACf,IAAA,IAAI,CAAC,cAAL,CAAoB,WAApB;AACD;;AACD,SAAO,IAAP;AACD;AAED;;;;;;AAIA,MAAM,oBAAN,CAA0B;AACxB;AACA,EAAA,WAAA,CACY,IADZ,EAEY,gBAFZ,EAE8D;AADlD,SAAA,IAAA,GAAA,IAAA;AACA,SAAA,gBAAA,GAAA,gBAAA;AACR;;AACJ,EAAA,gBAAgB,CAAC,MAAD,EAAiB,OAAjB,EAAgC;AAC9C,SAAK,IAAL,CAAU,gBAAV,CAA2B,MAA3B,EAAmC,OAAnC;AACD;;AACD,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,IAAL,CAAU,OAAV,EAAP;AACD;;AACD,EAAA,cAAc,CAAC,WAAD,EAA6B;AACzC,SAAK,IAAL,CAAU,cAAV,CAAyB,WAAzB;AACD,GAduB,CAexB;;;AACA,EAAA,sBAAsB,CAAC,OAAD,EAA0B,OAA1B,EAAsC;AAC1D,QAAI,UAAJ;;AACA,QAAI;AACF,MAAA,UAAU,GAAG,KAAK,gBAAL,CAAsB,gBAAtB,CAAuC,OAAvC,CAAb;AACA,WAAK,IAAL,CAAU,sBAAV,CAAiC,OAAjC,EAA0C,UAA1C;AACD,KAHD,CAGE,OAAO,CAAP,EAAU;AACV,WAAK,IAAL,CAAU,gBAAV,CAA2B,WAAA,CAAA,MAAA,CAAO,QAAlC,EAA4C,uBAA5C;AACD;AACF,GAxBuB,CAyBxB;;;AACA,EAAA,WAAW,CAAC,OAAD,EAAa;AACtB,SAAK,sBAAL,CAA4B,EAA5B,EAAgC,OAAhC;AACD;;AACD,EAAA,KAAK,CACH,QADG,EAEH,oBAFG,EAEiD;AAEpD,QAAI,SAAS,GAAwB,IAArC;AACA,SAAK,IAAL,CAAU,KAAV,CAAgB,QAAhB,EAA0B;AACxB,MAAA,iBAAiB,EAAE,QAAQ,IAAG;;;AAC5B,SAAA,EAAA,GAAA,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,iBAAtB,MAAuC,IAAvC,IAAuC,EAAA,KAAA,KAAA,CAAvC,GAAuC,KAAA,CAAvC,GAAuC,EAAA,CAAA,IAAA,CAAvC,oBAAuC,EAAG,QAAH,CAAvC;AACD,OAHuB;AAIxB,MAAA,gBAAgB,EAAE,OAAO,IAAG;eAAA,CAC1B;;;AACA,YAAI,YAAJ;;AACA,YAAI;AACF,UAAA,YAAY,GAAG,KAAK,gBAAL,CAAsB,mBAAtB,CAA0C,OAA1C,CAAf;AACA,WAAA,EAAA,GAAA,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,gBAAtB,MAAsC,IAAtC,IAAsC,EAAA,KAAA,KAAA,CAAtC,GAAsC,KAAA,CAAtC,GAAsC,EAAA,CAAA,IAAA,CAAtC,oBAAsC,EAAG,YAAH,CAAtC;AACD,SAHD,CAGE,OAAO,CAAP,EAAU;AACV,UAAA,SAAS,GAAG;AACV,YAAA,IAAI,EAAE,WAAA,CAAA,MAAA,CAAO,QADH;AAEV,YAAA,OAAO,EAAE,iCAFC;AAGV,YAAA,QAAQ,EAAE,IAAI,UAAA,CAAA,QAAJ;AAHA,WAAZ;AAKA,eAAK,IAAL,CAAU,gBAAV,CAA2B,SAAS,CAAC,IAArC,EAA2C,SAAS,CAAC,OAArD;AACD;AACF,OAlBuB;AAmBxB,MAAA,eAAe,EAAE,MAAM,IAAG;;;AACxB,YAAI,SAAJ,EAAe;AACb,WAAA,EAAA,GAAA,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,eAAtB,MAAqC,IAArC,IAAqC,EAAA,KAAA,KAAA,CAArC,GAAqC,KAAA,CAArC,GAAqC,EAAA,CAAA,IAAA,CAArC,oBAAqC,EAAG,SAAH,CAArC;AACD,SAFD,MAEO;AACL,WAAA,EAAA,GAAA,oBAAoB,KAAA,IAApB,IAAA,oBAAoB,KAAA,KAAA,CAApB,GAAoB,KAAA,CAApB,GAAA,oBAAoB,CAAE,eAAtB,MAAqC,IAArC,IAAqC,EAAA,KAAA,KAAA,CAArC,GAAqC,KAAA,CAArC,GAAqC,EAAA,CAAA,IAAA,CAArC,oBAAqC,EAAG,MAAH,CAArC;AACD;AACF;AAzBuB,KAA1B;AA2BD;;AACD,EAAA,SAAS,GAAA;AACP,SAAK,IAAL,CAAU,SAAV;AACD;;AACD,EAAA,SAAS,GAAA;AACP,SAAK,IAAL,CAAU,SAAV;AACD;;AAnEuB;AAsE1B;;;;;;AAIA,MAAM,yBAAN,SAAwC,oBAAxC,CAA4D;AAE1D;AACA,EAAA,WAAA,CAAY,IAAZ,EAAwB,gBAAxB,EAA0E;AACxE,UAAM,IAAN,EAAY,gBAAZ;AACD;;AACD,EAAA,KAAK,CAAC,QAAD,EAAqB,QAArB,EAA6D;;;AAChE,QAAI,eAAe,GAAG,KAAtB;AACA,UAAM,eAAe,GAAyB;AAC5C,MAAA,iBAAiB,EAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GACf,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,iBADK,MACY,IADZ,IACY,EAAA,KAAA,KAAA,CADZ,GACY,KAAA,CADZ,GACY,EAAA,CAAE,IAAF,CAAO,QAAP,CADZ,MAC2B,IAD3B,IAC2B,EAAA,KAAA,KAAA,CAD3B,GAC2B,EAD3B,GACiC,QAAQ,IAAG,CAAG,CAFpB;AAG5C;AACA,MAAA,gBAAgB,EAAG,OAAD,IAAiB;;;AACjC,QAAA,eAAe,GAAG,IAAlB;AACA,SAAA,EAAA,GAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,gBAAV,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,KAAA,CAA1B,GAA0B,EAAA,CAAA,IAAA,CAA1B,QAA0B,EAAG,OAAH,CAA1B;AACD,OAP2C;AAQ5C,MAAA,eAAe,EAAG,MAAD,IAAyB;;;AACxC,YAAI,CAAC,eAAL,EAAsB;AACpB,WAAA,EAAA,GAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,gBAAV,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,KAAA,CAA1B,GAA0B,EAAA,CAAA,IAAA,CAA1B,QAA0B,EAAG,IAAH,CAA1B;AACD;;AACD,SAAA,EAAA,GAAA,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,eAAV,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,KAAA,CAAzB,GAAyB,EAAA,CAAA,IAAA,CAAzB,QAAyB,EAAG,MAAH,CAAzB;AACD;AAb2C,KAA9C;AAeA,UAAM,KAAN,CAAY,QAAZ,EAAsB,eAAtB;AACA,SAAK,IAAL,CAAU,SAAV;AACD;;AAzByD;AA4B5D;;;;;;AAIA,MAAM,6BAAN,SAA4C,oBAA5C,CAAgE,E,CAGhE;;;AACA,SAAS,yBAAT,CACE,OADF,EAEE,OAFF,EAGE,gBAHF,EAGoD;AAElD,QAAM,IAAI,GAAG,OAAO,CAAC,OAAD,EAAU,gBAAgB,CAAC,IAA3B,EAAiC,OAAjC,CAApB;;AACA,MAAI,gBAAgB,CAAC,cAArB,EAAqC;AACnC,WAAO,IAAI,6BAAJ,CAAkC,IAAlC,EAAwC,gBAAxC,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAI,yBAAJ,CAA8B,IAA9B,EAAoC,gBAApC,CAAP;AACD;AACF,C,CAsBD;;;AACA,SAAgB,mBAAhB,CACE,eADF,EAEE,gBAFF,EAGE,OAHF,EAIE,OAJF,EAIkB;AAEhB,MACE,eAAe,CAAC,kBAAhB,CAAmC,MAAnC,GAA4C,CAA5C,IACA,eAAe,CAAC,0BAAhB,CAA2C,MAA3C,GAAoD,CAFtD,EAGE;AACA,UAAM,IAAI,6BAAJ,CACJ,wEACE,0DAFE,CAAN;AAID;;AACD,MACE,eAAe,CAAC,gBAAhB,CAAiC,MAAjC,GAA0C,CAA1C,IACA,eAAe,CAAC,wBAAhB,CAAyC,MAAzC,GAAkD,CAFpD,EAGE;AACA,UAAM,IAAI,6BAAJ,CACJ,qEACE,wCAFE,CAAN;AAID;;AACD,MAAI,YAAY,GAAkB,EAAlC,CApBgB,CAqBhB;;AACA,MACE,eAAe,CAAC,gBAAhB,CAAiC,MAAjC,GAA0C,CAA1C,IACA,eAAe,CAAC,wBAAhB,CAAyC,MAAzC,GAAkD,CAFpD,EAGE;AACA,IAAA,YAAY,GAAI,GACb,MADa,CAEZ,eAAe,CAAC,gBAFJ,EAGZ,eAAe,CAAC,wBAAhB,CAAyC,GAAzC,CAA6C,QAAQ,IACnD,QAAQ,CAAC,gBAAD,CADV,CAHY,EAOb,MAPa,CAON,WAAW,IAAI,WAPT,CAAhB,CADA,CASA;AACD,GAbD,MAaO;AACL,IAAA,YAAY,GAAI,GACb,MADa,CAEZ,eAAe,CAAC,kBAFJ,EAGZ,eAAe,CAAC,0BAAhB,CAA2C,GAA3C,CAA+C,QAAQ,IACrD,QAAQ,CAAC,gBAAD,CADV,CAHY,EAOb,MAPa,CAON,WAAW,IAAI,WAPT,CAAhB,CADK,CASL;AACD;;AACD,QAAM,kBAAkB,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,EAA2B;AACpD,IAAA,iBAAiB,EAAE;AADiC,GAA3B,CAA3B;AAGA;;;;;;;;AAOA,QAAM,OAAO,GAAa,YAAY,CAAC,WAAb,CACxB,CAAC,QAAD,EAAqB,eAArB,KAAqD;AACnD,WAAO,cAAc,IAAI,eAAe,CAAC,cAAD,EAAiB,QAAjB,CAAxC;AACD,GAHuB,EAIvB,YAAD,IACE,yBAAyB,CACvB,OADuB,EAEvB,YAFuB,EAGvB,gBAHuB,CALH,CAA1B;AAWA,SAAO,OAAO,CAAC,kBAAD,CAAd;AACD;;AAxED,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst metadata_1 = require(\"./metadata\");\nconst call_stream_1 = require(\"./call-stream\");\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InterceptorConfigurationError';\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor() {\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status,\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor() {\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel,\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n    onReceiveMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    onReceiveMessage: (message, next) => {\n        next(message);\n    },\n    onReceiveStatus: (status, next) => {\n        next(status);\n    },\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n    start: (metadata, listener, next) => {\n        next(metadata, listener);\n    },\n    sendMessage: (message, next) => {\n        next(message);\n    },\n    halfClose: next => {\n        next();\n    },\n    cancel: next => {\n        next();\n    },\n};\nclass InterceptingCall {\n    constructor(nextCall, requester) {\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that a message has been passed to the listener's onReceiveMessage\n         * method it has not been passed to the corresponding next callback\n         */\n        this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */\n        this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\n            };\n        }\n        else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(() => {\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),\n        };\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n            var _a, _b, _c;\n            let finalInterceptingListener;\n            if (call_stream_1.isInterceptingListener(listener)) {\n                finalInterceptingListener = listener;\n            }\n            else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\n                };\n                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n        });\n    }\n    // tslint:disable-next-line no-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, finalMessage => {\n            this.processingMessage = false;\n            this.nextCall.sendMessageWithContext(context, finalMessage);\n            if (this.pendingHalfClose) {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n    // tslint:disable-next-line no-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(() => {\n            if (this.processingMessage) {\n                this.pendingHalfClose = true;\n            }\n            else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n    setCredentials(credentials) {\n        this.nextCall.setCredentials(credentials);\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    let deadline;\n    let host;\n    const parent = null;\n    let propagateFlags;\n    let credentials;\n    if (options) {\n        deadline = options.deadline;\n        host = options.host;\n        propagateFlags = options.propagate_flags;\n        credentials = options.credentials;\n    }\n    if (deadline === undefined) {\n        deadline = Infinity;\n    }\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n    // tslint:disable-next-line no-any\n    constructor(call, methodDefinition) {\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    setCredentials(credentials) {\n        this.call.setCredentials(credentials);\n    }\n    // tslint:disable-next-line no-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n            this.call.sendMessageWithContext(context, serialized);\n        }\n        catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, 'Serialization failure');\n        }\n    }\n    // tslint:disable-next-line no-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: metadata => {\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: message => {\n                var _a;\n                // tslint:disable-next-line no-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n                }\n                catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: 'Failed to parse server response',\n                        metadata: new metadata_1.Metadata(),\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                }\n            },\n            onReceiveStatus: status => {\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                }\n                else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            },\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // tslint:disable-next-line no-any\n    constructor(call, methodDefinition) {\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            // tslint:disable-next-line no-any\n            onReceiveMessage: (message) => {\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            },\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\n// tslint:disable-next-line no-any\nfunction getBottomInterceptingCall(channel, options, methodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    }\n    else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\n// tslint:disable-next-line no-any\nfunction getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 &&\n        interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\n            'to the client constructor. Only one of these is allowed.');\n    }\n    if (interceptorArgs.callInterceptors.length > 0 &&\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\n            'options. Only one of these is allowed.');\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 ||\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = []\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    else {\n        interceptors = []\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition,\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n        return currentOptions => nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;\n//# sourceMappingURL=client-interceptors.js.map"]},"metadata":{},"sourceType":"script"}