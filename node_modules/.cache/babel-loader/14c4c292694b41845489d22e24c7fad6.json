{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst http2 = require(\"http2\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst server_call_1 = require(\"./server-call\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging_1 = require(\"./logging\");\n\nconst subchannel_1 = require(\"./subchannel\");\n\nfunction noop() {}\n\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n    metadata: new metadata_1.Metadata()\n  };\n}\n\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n} // tslint:enable:no-any\n\n\nclass Server {\n  constructor(options) {\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Set();\n    this.started = false;\n    this.options = options !== null && options !== void 0 ? options : {};\n  }\n\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(service, implementation) {\n    if (this.started === true) {\n      throw new Error(\"Can't add a service to a started server.\");\n    }\n\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || typeof creds !== 'object') {\n      throw new TypeError('creds must be an object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const serverOptions = {};\n\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n\n    const setupServer = () => {\n      let http2Server;\n\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        http2Server = http2.createSecureServer(secureServerOptions);\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n\n      http2Server.setTimeout(0, noop);\n\n      this._setupHandlers(http2Server);\n\n      return http2Server;\n    };\n\n    const bindSpecificPort = (addressList, portNum, previousCount) => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: portNum,\n          count: previousCount\n        });\n      }\n\n      return Promise.all(addressList.map(address => {\n        let addr;\n\n        if (subchannel_1.isTcpSubchannelAddress(address)) {\n          addr = {\n            host: address.host,\n            port: portNum\n          };\n        } else {\n          addr = address;\n        }\n\n        const http2Server = setupServer();\n        return new Promise((resolve, reject) => {\n          function onError(err) {\n            resolve(err);\n          }\n\n          http2Server.once('error', onError);\n          http2Server.listen(addr, () => {\n            this.http2ServerList.push(http2Server);\n            const boundAddress = http2Server.address();\n\n            if (typeof boundAddress === 'string') {\n              resolve(portNum);\n            } else {\n              resolve(boundAddress.port);\n            }\n\n            http2Server.removeListener('error', onError);\n          });\n        });\n      })).then(results => {\n        let count = 0;\n\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n\n            if (result !== portNum) {\n              throw new Error('Invalid state: multiple port numbers added from single address');\n            }\n          }\n        }\n\n        return {\n          port: portNum,\n          count: count + previousCount\n        };\n      });\n    };\n\n    const bindWildcardPort = addressList => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: 0,\n          count: 0\n        });\n      }\n\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise((resolve, reject) => {\n        function onError(err) {\n          resolve(bindWildcardPort(addressList.slice(1)));\n        }\n\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          this.http2ServerList.push(http2Server);\n          resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n\n    const resolverListener = {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n\n        if (addressList.length === 0) {\n          callback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n\n        let bindResultPromise;\n\n        if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n\n        bindResultPromise.then(bindResult => {\n          if (bindResult.count === 0) {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging_1.log(constants_1.LogVerbosity.ERROR, errorString);\n            callback(new Error(errorString), 0);\n          } else {\n            if (bindResult.count < addressList.length) {\n              logging_1.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n            }\n\n            callback(null, bindResult.port);\n          }\n        }, error => {\n          const errorString = `No address added out of total ${addressList.length} resolved`;\n          logging_1.log(constants_1.LogVerbosity.ERROR, errorString);\n          callback(new Error(errorString), 0);\n        });\n      },\n      onError: error => {\n        callback(new Error(error.details), 0);\n      }\n    };\n    const resolver = resolver_1.createResolver(port, resolverListener);\n    resolver.updateResolution();\n  }\n\n  forceShutdown() {\n    // Close the server if it is still running.\n    for (const http2Server of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close();\n      }\n    }\n\n    this.started = false; // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n\n    this.sessions.forEach(session => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // tslint:disable-next-line:no-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n  }\n\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type\n    });\n    return true;\n  }\n\n  start() {\n    if (this.http2ServerList.length === 0 || this.http2ServerList.every(http2Server => http2Server.listening !== true)) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    this.started = true;\n  }\n\n  tryShutdown(callback) {\n    let pendingChecks = 0;\n\n    function maybeCallback() {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        callback();\n      }\n    } // Close the server if necessary.\n\n\n    this.started = false;\n\n    for (const http2Server of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(maybeCallback);\n      }\n    } // If any sessions are active, close them gracefully.\n\n\n    pendingChecks += this.sessions.size;\n    this.sessions.forEach(session => {\n      session.close(maybeCallback);\n    });\n\n    if (pendingChecks === 0) {\n      callback();\n    }\n  }\n\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n\n  _setupHandlers(http2Server) {\n    if (http2Server === null) {\n      return;\n    }\n\n    http2Server.on('stream', (stream, headers) => {\n      const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n      if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n        stream.respond({\n          [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n        }, {\n          endStream: true\n        });\n        return;\n      }\n\n      try {\n        const path = headers[http2.constants.HTTP2_HEADER_PATH];\n        const handler = this.handlers.get(path);\n\n        if (handler === undefined) {\n          throw getUnimplementedStatusResponse(path);\n        }\n\n        const call = new server_call_1.Http2ServerCallStream(stream, handler);\n        const metadata = call.receiveMetadata(headers);\n\n        switch (handler.type) {\n          case 'unary':\n            handleUnary(call, handler, metadata);\n            break;\n\n          case 'clientStream':\n            handleClientStreaming(call, handler, metadata);\n            break;\n\n          case 'serverStream':\n            handleServerStreaming(call, handler, metadata);\n            break;\n\n          case 'bidi':\n            handleBidiStreaming(call, handler, metadata);\n            break;\n\n          default:\n            throw new Error(`Unknown handler type: ${handler.type}`);\n        }\n      } catch (err) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null);\n\n        if (err.code === undefined) {\n          err.code = constants_1.Status.INTERNAL;\n        }\n\n        call.sendError(err);\n      }\n    });\n    http2Server.on('session', session => {\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      this.sessions.add(session);\n    });\n  }\n\n}\n\nexports.Server = Server;\n\nasync function handleUnary(call, handler, metadata) {\n  const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata);\n  const request = await call.receiveUnaryMessage();\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  emitter.request = request;\n  handler.func(emitter, (err, value, trailer, flags) => {\n    call.sendUnaryMessage(err, value, trailer, flags);\n  });\n}\n\nfunction handleClientStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nasync function handleServerStreaming(call, handler, metadata) {\n  const request = await call.receiveUnaryMessage();\n\n  if (request === undefined || call.cancelled) {\n    return;\n  }\n\n  const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize);\n  stream.request = request;\n  handler.func(stream);\n}\n\nfunction handleBidiStreaming(call, handler, metadata) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}","map":{"version":3,"sources":["../../src/server.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http2 = require(\"http2\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst server_call_1 = require(\"./server-call\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst subchannel_1 = require(\"./subchannel\");\nfunction noop() { }\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`,\n        metadata: new metadata_1.Metadata(),\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch (handlerType) {\n        case 'unary':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback) => {\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call) => {\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\n// tslint:enable:no-any\nclass Server {\n    constructor(options) {\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Set();\n        this.started = false;\n        this.options = options !== null && options !== void 0 ? options : {};\n    }\n    addProtoService() {\n        throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n        if (this.started === true) {\n            throw new Error(\"Can't add a service to a started server.\");\n        }\n        if (service === null ||\n            typeof service !== 'object' ||\n            implementation === null ||\n            typeof implementation !== 'object') {\n            throw new Error('addService() requires two objects as arguments');\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error('Cannot add an empty service to a server');\n        }\n        serviceKeys.forEach(name => {\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = 'bidi';\n                }\n                else {\n                    methodType = 'clientStream';\n                }\n            }\n            else {\n                if (attrs.responseStream) {\n                    methodType = 'serverStream';\n                }\n                else {\n                    methodType = 'unary';\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === 'string') {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            }\n            else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    bind(port, creds) {\n        throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (typeof port !== 'string') {\n            throw new TypeError('port must be a string');\n        }\n        if (creds === null || typeof creds !== 'object') {\n            throw new TypeError('creds must be an object');\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback must be a function');\n        }\n        const serverOptions = {};\n        if ('grpc.max_concurrent_streams' in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n            };\n        }\n        const setupServer = () => {\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                http2Server = http2.createSecureServer(secureServerOptions);\n            }\n            else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: portNum, count: previousCount });\n            }\n            return Promise.all(addressList.map(address => {\n                let addr;\n                if (subchannel_1.isTcpSubchannelAddress(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                }\n                else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject) => {\n                    function onError(err) {\n                        resolve(err);\n                    }\n                    http2Server.once('error', onError);\n                    http2Server.listen(addr, () => {\n                        this.http2ServerList.push(http2Server);\n                        const boundAddress = http2Server.address();\n                        if (typeof boundAddress === 'string') {\n                            resolve(portNum);\n                        }\n                        else {\n                            resolve(boundAddress.port);\n                        }\n                        http2Server.removeListener('error', onError);\n                    });\n                });\n            })).then(results => {\n                let count = 0;\n                for (const result of results) {\n                    if (typeof result === 'number') {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error('Invalid state: multiple port numbers added from single address');\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList) => {\n            if (addressList.length === 0) {\n                return Promise.resolve({ port: 0, count: 0 });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject) => {\n                function onError(err) {\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                }\n                http2Server.once('error', onError);\n                http2Server.listen(address, () => {\n                    this.http2ServerList.push(http2Server);\n                    resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));\n                    http2Server.removeListener('error', onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = () => { };\n                if (addressList.length === 0) {\n                    callback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    }\n                    else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                }\n                else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then(bindResult => {\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging_1.log(constants_1.LogVerbosity.ERROR, errorString);\n                        callback(new Error(errorString), 0);\n                    }\n                    else {\n                        if (bindResult.count < addressList.length) {\n                            logging_1.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        callback(null, bindResult.port);\n                    }\n                }, (error) => {\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging_1.log(constants_1.LogVerbosity.ERROR, errorString);\n                    callback(new Error(errorString), 0);\n                });\n            },\n            onError: (error) => {\n                callback(new Error(error.details), 0);\n            }\n        };\n        const resolver = resolver_1.createResolver(port, resolverListener);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const http2Server of this.http2ServerList) {\n            if (http2Server.listening) {\n                http2Server.close();\n            }\n        }\n        this.started = false;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach(session => {\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // tslint:disable-next-line:no-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n        });\n        return true;\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(http2Server => http2Server.listening !== true)) {\n            throw new Error('server must be bound in order to start');\n        }\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                callback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        for (const http2Server of this.http2ServerList) {\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(maybeCallback);\n            }\n        }\n        // If any sessions are active, close them gracefully.\n        pendingChecks += this.sessions.size;\n        this.sessions.forEach(session => {\n            session.close(maybeCallback);\n        });\n        if (pendingChecks === 0) {\n            callback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error('Not yet implemented');\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        http2Server.on('stream', (stream, headers) => {\n            const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n            if (typeof contentType !== 'string' ||\n                !contentType.startsWith('application/grpc')) {\n                stream.respond({\n                    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n                }, { endStream: true });\n                return;\n            }\n            try {\n                const path = headers[http2.constants.HTTP2_HEADER_PATH];\n                const handler = this.handlers.get(path);\n                if (handler === undefined) {\n                    throw getUnimplementedStatusResponse(path);\n                }\n                const call = new server_call_1.Http2ServerCallStream(stream, handler);\n                const metadata = call.receiveMetadata(headers);\n                switch (handler.type) {\n                    case 'unary':\n                        handleUnary(call, handler, metadata);\n                        break;\n                    case 'clientStream':\n                        handleClientStreaming(call, handler, metadata);\n                        break;\n                    case 'serverStream':\n                        handleServerStreaming(call, handler, metadata);\n                        break;\n                    case 'bidi':\n                        handleBidiStreaming(call, handler, metadata);\n                        break;\n                    default:\n                        throw new Error(`Unknown handler type: ${handler.type}`);\n                }\n            }\n            catch (err) {\n                const call = new server_call_1.Http2ServerCallStream(stream, null);\n                if (err.code === undefined) {\n                    err.code = constants_1.Status.INTERNAL;\n                }\n                call.sendError(err);\n            }\n        });\n        http2Server.on('session', session => {\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            this.sessions.add(session);\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata) {\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata);\n    const request = await call.receiveUnaryMessage();\n    if (request === undefined || call.cancelled) {\n        return;\n    }\n    emitter.request = request;\n    handler.func(emitter, (err, value, trailer, flags) => {\n        call.sendUnaryMessage(err, value, trailer, flags);\n    });\n}\nfunction handleClientStreaming(call, handler, metadata) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on('error', respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata) {\n    const request = await call.receiveUnaryMessage();\n    if (request === undefined || call.cancelled) {\n        return;\n    }\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize);\n    stream.request = request;\n    handler.func(stream);\n}\nfunction handleBidiStreaming(call, handler, metadata) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n}\n//# sourceMappingURL=server.js.map"]},"metadata":{},"sourceType":"script"}