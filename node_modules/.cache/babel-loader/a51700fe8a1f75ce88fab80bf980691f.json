{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst call_1 = require(\"./call\");\n\nconst channel_1 = require(\"./channel\");\n\nconst constants_1 = require(\"./constants\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst client_interceptors_1 = require(\"./client-interceptors\");\n\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\n\nclass Client {\n  constructor(address, credentials, options = {}) {\n    var _a, _b;\n\n    options = Object.assign({}, options);\n    this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n    delete options.interceptors;\n    this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n    delete options.interceptor_providers;\n\n    if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n      throw new Error('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n    }\n\n    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n    delete options.callInvocationTransformer;\n\n    if (options.channelOverride) {\n      this[CHANNEL_SYMBOL] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      const channelFactoryOverride = options.channelFactoryOverride;\n      delete options.channelFactoryOverride;\n      this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n    } else {\n      this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n    }\n  }\n\n  close() {\n    this[CHANNEL_SYMBOL].close();\n  }\n\n  getChannel() {\n    return this[CHANNEL_SYMBOL];\n  }\n\n  waitForReady(deadline, callback) {\n    const checkState = err => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n\n      let newState;\n\n      try {\n        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n\n      if (newState === channel_1.ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n\n    setImmediate(checkState);\n  }\n\n  checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n    if (arg1 instanceof Function) {\n      return {\n        metadata: new metadata_1.Metadata(),\n        options: {},\n        callback: arg1\n      };\n    } else if (arg2 instanceof Function) {\n      if (arg1 instanceof metadata_1.Metadata) {\n        return {\n          metadata: arg1,\n          options: {},\n          callback: arg2\n        };\n      } else {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: arg1,\n          callback: arg2\n        };\n      }\n    } else {\n      if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && arg3 instanceof Function)) {\n        throw new Error('Incorrect arguments passed');\n      }\n\n      return {\n        metadata: arg1,\n        options: arg2,\n        callback: arg3\n      };\n    }\n  }\n\n  makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n    var _a, _b;\n\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientUnaryCallImpl(),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    emitter.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let responseMessage = null;\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n\n      // tslint:disable-next-line no-any\n      onReceiveMessage(message) {\n        if (responseMessage != null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n        }\n\n        responseMessage = message;\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n\n        if (status.code === constants_1.Status.OK) {\n          callProperties.callback(null, responseMessage);\n        } else {\n          callProperties.callback(call_1.callErrorFromStatus(status));\n        }\n\n        emitter.emit('status', status);\n      }\n\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return emitter;\n  }\n\n  makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n    var _a, _b;\n\n    const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: false,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientWritableStreamImpl(serialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options,\n      callback: checkedArguments.callback\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const emitter = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    emitter.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let responseMessage = null;\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata: metadata => {\n        emitter.emit('metadata', metadata);\n      },\n\n      // tslint:disable-next-line no-any\n      onReceiveMessage(message) {\n        if (responseMessage != null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n        }\n\n        responseMessage = message;\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n\n        if (status.code === constants_1.Status.OK) {\n          callProperties.callback(null, responseMessage);\n        } else {\n          callProperties.callback(call_1.callErrorFromStatus(status));\n        }\n\n        emitter.emit('status', status);\n      }\n\n    });\n    return emitter;\n  }\n\n  checkMetadataAndOptions(arg1, arg2) {\n    let metadata;\n    let options;\n\n    if (arg1 instanceof metadata_1.Metadata) {\n      metadata = arg1;\n\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n\n      metadata = new metadata_1.Metadata();\n    }\n\n    return {\n      metadata,\n      options\n    };\n  }\n\n  makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n    var _a, _b;\n\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: false,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      argument: argument,\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientReadableStreamImpl(deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    stream.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n\n      // tslint:disable-next-line no-any\n      onReceiveMessage(message) {\n        if (stream.push(message)) {\n          call.startRead();\n        }\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n        stream.push(null);\n\n        if (status.code !== constants_1.Status.OK) {\n          stream.emit('error', call_1.callErrorFromStatus(status));\n        }\n\n        stream.emit('status', status);\n      }\n\n    });\n    call.sendMessage(argument);\n    call.halfClose();\n    return stream;\n  }\n\n  makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n    var _a, _b;\n\n    const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n    const methodDefinition = {\n      path: method,\n      requestStream: true,\n      responseStream: true,\n      requestSerialize: serialize,\n      responseDeserialize: deserialize\n    };\n    let callProperties = {\n      metadata: checkedArguments.metadata,\n      call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n      channel: this[CHANNEL_SYMBOL],\n      methodDefinition: methodDefinition,\n      callOptions: checkedArguments.options\n    };\n\n    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n    }\n\n    const stream = callProperties.call;\n    const interceptorArgs = {\n      clientInterceptors: this[INTERCEPTOR_SYMBOL],\n      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n      callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n      callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n    };\n    const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n    /* This needs to happen before the emitter is used. Unfortunately we can't\n     * enforce this with the type system. We need to construct this emitter\n     * before calling the CallInvocationTransformer, and we need to create the\n     * call after that. */\n\n    stream.call = call;\n\n    if (callProperties.callOptions.credentials) {\n      call.setCredentials(callProperties.callOptions.credentials);\n    }\n\n    let receivedStatus = false;\n    call.start(callProperties.metadata, {\n      onReceiveMetadata(metadata) {\n        stream.emit('metadata', metadata);\n      },\n\n      onReceiveMessage(message) {\n        if (stream.push(message)) {\n          call.startRead();\n        }\n      },\n\n      onReceiveStatus(status) {\n        if (receivedStatus) {\n          return;\n        }\n\n        receivedStatus = true;\n        stream.push(null);\n\n        if (status.code !== constants_1.Status.OK) {\n          stream.emit('error', call_1.callErrorFromStatus(status));\n        }\n\n        stream.emit('status', status);\n      }\n\n    });\n    return stream;\n  }\n\n}\n\nexports.Client = Client;","map":{"version":3,"sources":["../../src/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst call_1 = require(\"./call\");\nconst channel_1 = require(\"./channel\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst client_interceptors_1 = require(\"./client-interceptors\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\n                'to the client constructor. Only one of these is allowed.');\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === channel_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (arg1 instanceof Function) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (arg2 instanceof Function) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!(arg1 instanceof metadata_1.Metadata &&\n                arg2 instanceof Object &&\n                arg3 instanceof Function)) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // tslint:disable-next-line no-any\n            onReceiveMessage(message) {\n                if (responseMessage != null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    callProperties.callback(null, responseMessage);\n                }\n                else {\n                    callProperties.callback(call_1.callErrorFromStatus(status));\n                }\n                emitter.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // tslint:disable-next-line no-any\n            onReceiveMessage(message) {\n                if (responseMessage != null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    callProperties.callback(null, responseMessage);\n                }\n                else {\n                    callProperties.callback(call_1.callErrorFromStatus(status));\n                }\n                emitter.emit('status', status);\n            },\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            // tslint:disable-next-line no-any\n            onReceiveMessage(message) {\n                if (stream.push(message)) {\n                    call.startRead();\n                }\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    stream.emit('error', call_1.callErrorFromStatus(status));\n                }\n                stream.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            onReceiveMessage(message) {\n                if (stream.push(message)) {\n                    call.startRead();\n                }\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    stream.emit('error', call_1.callErrorFromStatus(status));\n                }\n                stream.emit('status', status);\n            },\n        });\n        return stream;\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}