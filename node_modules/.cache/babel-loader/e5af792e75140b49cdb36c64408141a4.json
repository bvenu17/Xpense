{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deepEqual = require('deep-equal');\n\nconst through2 = require(\"through2\");\n\nconst document_1 = require(\"./document\");\n\nconst document_change_1 = require(\"./document-change\");\n\nconst logger_1 = require(\"./logger\");\n\nconst order_1 = require(\"./order\");\n\nconst path_1 = require(\"./path\");\n\nconst serializer_1 = require(\"./serializer\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst types_1 = require(\"./types\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst watch_1 = require(\"./watch\");\n\nconst write_batch_1 = require(\"./write-batch\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n */\n\n\nconst directionOperators = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '>=', '>', 'array-contains', 'in', and\n * 'array-contains-any'.\n *\n * @private\n */\n\nconst comparisonOperators = {\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  in: 'IN',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY'\n};\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class\n */\n\nclass DocumentReference {\n  /**\n   * @hideconstructor\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _path The Path of this reference.\n   */\n  constructor(_firestore, _path, _converter = types_1.defaultConverter) {\n    this._firestore = _firestore;\n    this._path = _path;\n    this._converter = _converter;\n  }\n  /**\n   * The string representation of the DocumentReference's location.\n   * @private\n   * @type {string}\n   * @name DocumentReference#formattedName\n   */\n\n\n  get formattedName() {\n    const projectId = this.firestore.projectId;\n    return this._path.toQualifiedResourcePath(projectId).formattedName;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name DocumentReference#firestore\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   */\n\n\n  get firestore() {\n    return this._firestore;\n  }\n  /**\n   * A string representing the path of the referenced document (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name DocumentReference#path\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document at '${documentReference.path}'`);\n   * });\n   */\n\n\n  get path() {\n    return this._path.relativeName;\n  }\n  /**\n   * The last path element of the referenced document.\n   *\n   * @type {string}\n   * @name DocumentReference#id\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name '${documentReference.id}'`);\n   * });\n   */\n\n\n  get id() {\n    return this._path.id;\n  }\n  /**\n   * A reference to the collection to which this DocumentReference belongs.\n   *\n   * @name DocumentReference#parent\n   * @type {CollectionReference}\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   * let collectionRef = documentRef.parent;\n   *\n   * collectionRef.where('foo', '==', 'bar').get().then(results => {\n   *   console.log(`Found ${results.size} matches in parent collection`);\n   * }):\n   */\n\n\n  get parent() {\n    return new CollectionReference(this._firestore, this._path.parent(), this._converter);\n  }\n  /**\n   * Reads the document referred to by this DocumentReference.\n   *\n   * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n   * DocumentSnapshot for the retrieved document on success. For missing\n   * documents, DocumentSnapshot.exists will be false. If the get() fails for\n   * other reasons, the Promise will be rejected.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log('Document retrieved successfully.');\n   *   }\n   * });\n   */\n\n\n  get() {\n    return this._firestore.getAll(this).then(([result]) => result);\n  }\n  /**\n   * Gets a [CollectionReference]{@link CollectionReference} instance\n   * that refers to the collection at the specified path.\n   *\n   * @param {string} collectionPath A slash-separated path to a collection.\n   * @returns {CollectionReference} A reference to the new\n   * subcollection.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   * let subcollection = documentRef.collection('subcollection');\n   * console.log(`Path to subcollection: ${subcollection.path}`);\n   */\n\n\n  collection(collectionPath) {\n    path_1.validateResourcePath('collectionPath', collectionPath);\n\n    const path = this._path.append(collectionPath);\n\n    if (!path.isCollection) {\n      throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n    }\n\n    return new CollectionReference(this._firestore, path);\n  }\n  /**\n   * Fetches the subcollections that are direct children of this document.\n   *\n   * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n   * with an array of CollectionReferences.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.listCollections().then(collections => {\n   *   for (let collection of collections) {\n   *     console.log(`Found subcollection with id: ${collection.id}`);\n   *   }\n   * });\n   */\n\n\n  listCollections() {\n    const tag = util_1.requestTag();\n    return this.firestore.initializeIfNeeded(tag).then(() => {\n      const request = {\n        parent: this.formattedName,\n        // Setting `pageSize` to an arbitrarily large value lets the backend cap\n        // the page size (currently to 300). Note that the backend rejects\n        // MAX_INT32 (b/146883794).\n        pageSize: Math.pow(2, 16) - 1\n      };\n      return this._firestore.request('listCollectionIds', request, tag).then(collectionIds => {\n        const collections = []; // We can just sort this list using the default comparator since it\n        // will only contain collection ids.\n\n        collectionIds.sort();\n\n        for (const collectionId of collectionIds) {\n          collections.push(this.collection(collectionId));\n        }\n\n        return collections;\n      });\n    });\n  }\n  /**\n   * Create a document with the provided object values. This will fail the write\n   * if a document exists at its location.\n   *\n   * @param {DocumentData} data An object that contains the fields and data to\n   * serialize as the document.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this create.\n   *\n   * @example\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * documentRef.create({foo: 'bar'}).then((res) => {\n   *   console.log(`Document created at ${res.updateTime}`);\n   * }).catch((err) => {\n   *   console.log(`Failed to create document: ${err}`);\n   * });\n   */\n\n\n  create(data) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.create(this, data).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Deletes the document referred to by this `DocumentReference`.\n   *\n   * A delete for a non-existing document is treated as a success (unless\n   * lastUptimeTime is provided).\n   *\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the delete if the\n   * document was last updated at a different time.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * delete time.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.delete().then(() => {\n   *   console.log('Document successfully deleted.');\n   * });\n   */\n\n\n  delete(precondition) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.delete(this, precondition).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Writes to the document referred to by this DocumentReference. If the\n   * document does not yet exist, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n   * existing document.\n   *\n   * @param {T} data A map of the fields and values for the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge If true, set() merges the values specified\n   * in its data argument. Fields omitted from this set() call remain untouched.\n   * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this set.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(res => {\n   *   console.log(`Document written at ${res.updateTime}`);\n   * });\n   */\n\n\n  set(data, options) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.set(this, data, options).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Updates fields in the document referred to by this DocumentReference.\n   * If the document doesn't yet exist, the update fails and the returned\n   * Promise will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n   * fields and values with which to update the document or the path of the\n   * first field to update.\n   * @param {\n   * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n   * list of field paths and values to update or a Precondition to restrict\n   * this update.\n   * @returns {Promise.<WriteResult>} A Promise that resolves once the\n   * data has been successfully written to the backend.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.update({foo: 'bar'}).then(res => {\n   *   console.log(`Document updated at ${res.updateTime}`);\n   * });\n   */\n\n\n  update(dataOrField, ...preconditionOrValues) {\n    validate_1.validateMinNumberOfArguments('DocumentReference.update', arguments, 1);\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.update(this, dataOrField, ...preconditionOrValues).commit().then(([writeResult]) => writeResult);\n  }\n  /**\n   * Attaches a listener for DocumentSnapshot events.\n   *\n   * @param {documentSnapshotCallback} onNext A callback to be called every\n   * time a new `DocumentSnapshot` is available.\n   * @param {errorCallback=} onError A callback to be called if the listen fails\n   * or is cancelled. No further callbacks will occur. If unset, errors will be\n   * logged to the console.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(documentSnapshot.data());\n   *   }\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   */\n\n\n  onSnapshot(onNext, onError) {\n    validate_1.validateFunction('onNext', onNext);\n    validate_1.validateFunction('onError', onError, {\n      optional: true\n    });\n    const watch = new watch_1.DocumentWatch(this.firestore, this);\n    return watch.onSnapshot((readTime, size, docs) => {\n      for (const document of docs()) {\n        if (document.ref.path === this.path) {\n          onNext(document);\n          return;\n        }\n      } // The document is missing.\n\n\n      const ref = new DocumentReference(this._firestore, this._path, this._converter);\n      const document = new document_1.DocumentSnapshotBuilder(ref);\n      document.readTime = readTime;\n      onNext(document.build());\n    }, onError || console.error);\n  }\n  /**\n   * Returns true if this `DocumentReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentReference` is equal to the provided\n   * value.\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path) && this._converter === other._converter;\n  }\n  /**\n   * Converts this DocumentReference to the Firestore Proto representation.\n   *\n   * @private\n   */\n\n\n  toProto() {\n    return {\n      referenceValue: this.formattedName\n    };\n  }\n  /**\n   * Applies a custom data converter to this DocumentReference, allowing you\n   * to use your own custom model objects with Firestore. When you call\n   * set(), get(), etc. on the returned DocumentReference instance, the\n   * provided converter will convert between Firestore data and your custom\n   * type U.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * @example\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     data: FirebaseFirestore.DocumentData\n   *   ): Post {\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * @param converter Converts objects to and from Firestore.\n   * @return A DocumentReference<U> that uses the provided converter.\n   */\n\n\n  withConverter(converter) {\n    return new DocumentReference(this.firestore, this._path, converter);\n  }\n\n}\n\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @class\n */\n\nclass FieldOrder {\n  /**\n   * @param field The name of a document field (member) on which to order query\n   * results.\n   * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n   * set the ordering direction to ascending or descending, respectively.\n   */\n  constructor(field, direction = 'ASCENDING') {\n    this.field = field;\n    this.direction = direction;\n  }\n  /**\n   * Generates the proto representation for this field order.\n   * @private\n   */\n\n\n  toProto() {\n    return {\n      field: {\n        fieldPath: this.field.formattedName\n      },\n      direction: this.direction\n    };\n  }\n\n}\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @class\n */\n\n\nclass FieldFilter {\n  /**\n   * @param serializer The Firestore serializer\n   * @param field The path of the property value to compare.\n   * @param op A comparison operation.\n   * @param value The value to which to compare the field for inclusion in a\n   * query.\n   */\n  constructor(serializer, field, op, value) {\n    this.serializer = serializer;\n    this.field = field;\n    this.op = op;\n    this.value = value;\n  }\n  /**\n   * Returns whether this FieldFilter uses an equals comparison.\n   *\n   * @private\n   */\n\n\n  isInequalityFilter() {\n    switch (this.op) {\n      case 'GREATER_THAN':\n      case 'GREATER_THAN_OR_EQUAL':\n      case 'LESS_THAN':\n      case 'LESS_THAN_OR_EQUAL':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n  /**\n   * Generates the proto representation for this field filter.\n   *\n   * @private\n   */\n\n\n  toProto() {\n    if (typeof this.value === 'number' && isNaN(this.value)) {\n      return {\n        unaryFilter: {\n          field: {\n            fieldPath: this.field.formattedName\n          },\n          op: 'IS_NAN'\n        }\n      };\n    }\n\n    if (this.value === null) {\n      return {\n        unaryFilter: {\n          field: {\n            fieldPath: this.field.formattedName\n          },\n          op: 'IS_NULL'\n        }\n      };\n    }\n\n    return {\n      fieldFilter: {\n        field: {\n          fieldPath: this.field.formattedName\n        },\n        op: this.op,\n        value: this.serializer.encodeValue(this.value)\n      }\n    };\n  }\n\n}\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\n\n\nclass QuerySnapshot {\n  /**\n   * @hideconstructor\n   *\n   * @param _query The originating query.\n   * @param _readTime The time when this query snapshot was obtained.\n   * @param _size The number of documents in the result set.\n   * @param docs A callback returning a sorted array of documents matching\n   * this query\n   * @param changes A callback returning a sorted array of document change\n   * events for this snapshot.\n   */\n  constructor(_query, _readTime, _size, docs, changes) {\n    this._query = _query;\n    this._readTime = _readTime;\n    this._size = _size;\n    this._materializedDocs = null;\n    this._materializedChanges = null;\n    this._docs = null;\n    this._changes = null;\n    this._docs = docs;\n    this._changes = changes;\n  }\n  /**\n   * The query on which you called get() or onSnapshot() in order to get this\n   * QuerySnapshot.\n   *\n   * @type {Query}\n   * @name QuerySnapshot#query\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.limit(10).get().then(querySnapshot => {\n   *   console.log(`Returned first batch of results`);\n   *   let query = querySnapshot.query;\n   *   return query.offset(10).get();\n   * }).then(() => {\n   *   console.log(`Returned second batch of results`);\n   * });\n   */\n\n\n  get query() {\n    return this._query;\n  }\n  /**\n   * An array of all the documents in this QuerySnapshot.\n   *\n   * @type {Array.<QueryDocumentSnapshot>}\n   * @name QuerySnapshot#docs\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   let docs = querySnapshot.docs;\n   *   for (let doc of docs) {\n   *     console.log(`Document found at path: ${doc.ref.path}`);\n   *   }\n   * });\n   */\n\n\n  get docs() {\n    if (this._materializedDocs) {\n      return this._materializedDocs;\n    }\n\n    this._materializedDocs = this._docs();\n    this._docs = null;\n    return this._materializedDocs;\n  }\n  /**\n   * True if there are no documents in the QuerySnapshot.\n   *\n   * @type {boolean}\n   * @name QuerySnapshot#empty\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   if (querySnapshot.empty) {\n   *     console.log('No documents found.');\n   *   }\n   * });\n   */\n\n\n  get empty() {\n    return this._size === 0;\n  }\n  /**\n   * The number of documents in the QuerySnapshot.\n   *\n   * @type {number}\n   * @name QuerySnapshot#size\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   console.log(`Found ${querySnapshot.size} documents.`);\n   * });\n   */\n\n\n  get size() {\n    return this._size;\n  }\n  /**\n   * The time this query snapshot was obtained.\n   *\n   * @type {Timestamp}\n   * @name QuerySnapshot#readTime\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then((querySnapshot) => {\n   *   let readTime = querySnapshot.readTime;\n   *   console.log(`Query results returned at '${readTime.toDate()}'`);\n   * });\n   */\n\n\n  get readTime() {\n    return this._readTime;\n  }\n  /**\n   * Returns an array of the documents changes since the last snapshot. If\n   * this is the first snapshot, all documents will be in the list as added\n   * changes.\n   *\n   * @return {Array.<DocumentChange>}\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.onSnapshot(querySnapshot => {\n   *   let changes = querySnapshot.docChanges();\n   *   for (let change of changes) {\n   *     console.log(`A document was ${change.type}.`);\n   *   }\n   * });\n   */\n\n\n  docChanges() {\n    if (this._materializedChanges) {\n      return this._materializedChanges;\n    }\n\n    this._materializedChanges = this._changes();\n    this._changes = null;\n    return this._materializedChanges;\n  }\n  /**\n   * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n   * method for running the same callback on each {@link QueryDocumentSnapshot}\n   * that is returned.\n   *\n   * @param {function} callback A callback to be called with a\n   * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n   * the snapshot.\n   * @param {*=} thisArg The `this` binding for the callback..\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  forEach(callback, thisArg) {\n    validate_1.validateFunction('callback', callback);\n\n    for (const doc of this.docs) {\n      callback.call(thisArg, doc);\n    }\n  }\n  /**\n   * Returns true if the document data in this `QuerySnapshot` is equal to the\n   * provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n   * value.\n   */\n\n\n  isEqual(other) {\n    // Since the read time is different on every query read, we explicitly\n    // ignore all metadata in this comparison.\n    if (this === other) {\n      return true;\n    }\n\n    if (!(other instanceof QuerySnapshot)) {\n      return false;\n    }\n\n    if (this._size !== other._size) {\n      return false;\n    }\n\n    if (!this._query.isEqual(other._query)) {\n      return false;\n    }\n\n    if (this._materializedDocs && !this._materializedChanges) {\n      // If we have only materialized the documents, we compare them first.\n      return isArrayEqual(this.docs, other.docs) && isArrayEqual(this.docChanges(), other.docChanges());\n    } // Otherwise, we compare the changes first as we expect there to be fewer.\n\n\n    return isArrayEqual(this.docChanges(), other.docChanges()) && isArrayEqual(this.docs, other.docs);\n  }\n\n}\n\nexports.QuerySnapshot = QuerySnapshot; // TODO: As of v0.17.0, we're changing docChanges from an array into a method.\n// Because this is a runtime breaking change and somewhat subtle (both Array and\n// Function have a .length, etc.), we'll replace commonly-used properties\n// (including Symbol.iterator) to throw a custom error message. By our v1.0\n// release, we should remove this code.\n\nfunction throwDocChangesMethodError() {\n  throw new Error('QuerySnapshot.docChanges has been changed from a property into a ' + 'method, so usages like \"querySnapshot.docChanges\" should become ' + '\"querySnapshot.docChanges()\"');\n}\n\nconst docChangesPropertiesToOverride = ['length', 'forEach', 'map', ...(typeof Symbol !== 'undefined' ? [Symbol.iterator] : [])];\ndocChangesPropertiesToOverride.forEach(property => {\n  Object.defineProperty(QuerySnapshot.prototype.docChanges, property, {\n    get: () => throwDocChangesMethodError()\n  });\n});\n/*!\n * Denotes whether a provided limit is applied to the beginning or the end of\n * the result set.\n */\n\nvar LimitType;\n\n(function (LimitType) {\n  LimitType[LimitType[\"First\"] = 0] = \"First\";\n  LimitType[LimitType[\"Last\"] = 1] = \"Last\";\n})(LimitType || (LimitType = {}));\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n */\n\n\nclass QueryOptions {\n  constructor(parentPath, collectionId, converter, allDescendants, fieldFilters, fieldOrders, startAt, endAt, limit, limitType, offset, projection) {\n    this.parentPath = parentPath;\n    this.collectionId = collectionId;\n    this.converter = converter;\n    this.allDescendants = allDescendants;\n    this.fieldFilters = fieldFilters;\n    this.fieldOrders = fieldOrders;\n    this.startAt = startAt;\n    this.endAt = endAt;\n    this.limit = limit;\n    this.limitType = limitType;\n    this.offset = offset;\n    this.projection = projection;\n  }\n  /**\n   * Returns query options for a collection group query.\n   * @private\n   */\n\n\n  static forCollectionGroupQuery(collectionId, converter = types_1.defaultConverter) {\n    return new QueryOptions(\n    /*parentPath=*/\n    path_1.ResourcePath.EMPTY, collectionId, converter,\n    /*allDescendants=*/\n    true,\n    /*fieldFilters=*/\n    [],\n    /*fieldOrders=*/\n    []);\n  }\n  /**\n   * Returns query options for a single-collection query.\n   * @private\n   */\n\n\n  static forCollectionQuery(collectionRef, converter = types_1.defaultConverter) {\n    return new QueryOptions(collectionRef.parent(), collectionRef.id, converter,\n    /*allDescendants=*/\n    false,\n    /*fieldFilters=*/\n    [],\n    /*fieldOrders=*/\n    []);\n  }\n  /**\n   * Returns the union of the current and the provided options.\n   * @private\n   */\n\n\n  with(settings) {\n    return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.fieldFilters, this.fieldFilters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection));\n  }\n\n  withConverter(converter) {\n    return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.fieldFilters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);\n  }\n\n  hasFieldOrders() {\n    return this.fieldOrders.length > 0;\n  }\n\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n\n    return other instanceof QueryOptions && this.parentPath.isEqual(other.parentPath) && this.collectionId === other.collectionId && this.converter === other.converter && this.allDescendants === other.allDescendants && this.limit === other.limit && this.offset === other.offset && deepEqual(this.fieldFilters, other.fieldFilters, {\n      strict: true\n    }) && deepEqual(this.fieldOrders, other.fieldOrders, {\n      strict: true\n    }) && deepEqual(this.startAt, other.startAt, {\n      strict: true\n    }) && deepEqual(this.endAt, other.endAt, {\n      strict: true\n    }) && deepEqual(this.projection, other.projection, {\n      strict: true\n    });\n  }\n\n}\n\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\n\nclass Query {\n  /**\n   * @hideconstructor\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _queryOptions Options that define the query.\n   */\n  constructor(_firestore, _queryOptions) {\n    this._firestore = _firestore;\n    this._queryOptions = _queryOptions;\n    this._serializer = new serializer_1.Serializer(_firestore);\n  }\n  /**\n   * Detects the argument type for Firestore cursors.\n   *\n   * @private\n   * @param fieldValuesOrDocumentSnapshot A snapshot of the document or a set\n   * of field values.\n   * @returns 'true' if the input is a single DocumentSnapshot..\n   */\n\n\n  static _isDocumentSnapshot(fieldValuesOrDocumentSnapshot) {\n    return fieldValuesOrDocumentSnapshot.length === 1 && fieldValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot;\n  }\n  /**\n   * Extracts field values from the DocumentSnapshot based on the provided\n   * field order.\n   *\n   * @private\n   * @param documentSnapshot The document to extract the fields from.\n   * @param fieldOrders The field order that defines what fields we should\n   * extract.\n   * @return {Array.<*>} The field values to use.\n   * @private\n   */\n\n\n  static _extractFieldValues(documentSnapshot, fieldOrders) {\n    const fieldValues = [];\n\n    for (const fieldOrder of fieldOrders) {\n      if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n        fieldValues.push(documentSnapshot.ref);\n      } else {\n        const fieldValue = documentSnapshot.get(fieldOrder.field);\n\n        if (fieldValue === undefined) {\n          throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` + 'Please provide a document that contains values for all specified ' + 'orderBy() and where() constraints.');\n        } else {\n          fieldValues.push(fieldValue);\n        }\n      }\n    }\n\n    return fieldValues;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name Query#firestore\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   */\n\n\n  get firestore() {\n    return this._firestore;\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} with the additional filter\n   * that documents must contain the specified field and that its value should\n   * satisfy the relation constraint provided.\n   *\n   * Returns a new Query that constrains the value of a Document property.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the filter.\n   *\n   * @param {string|FieldPath} fieldPath The name of a property value to compare.\n   * @param {string} opStr A comparison operation in the form of a string\n   * (e.g., \"<\").\n   * @param {*} value The value to which to compare the field for inclusion in\n   * a query.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  where(fieldPath, opStr, value) {\n    path_1.validateFieldPath('fieldPath', fieldPath);\n    opStr = validateQueryOperator('opStr', opStr, value);\n    validateQueryValue('value', value);\n\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify a where() filter after calling startAt(), ' + 'startAfter(), endBefore() or endAt().');\n    }\n\n    const path = path_1.FieldPath.fromArgument(fieldPath);\n\n    if (path_1.FieldPath.documentId().isEqual(path)) {\n      if (opStr === 'array-contains' || opStr === 'array-contains-any') {\n        throw new Error(`Invalid Query. You can't perform '${opStr}' ` + 'queries on FieldPath.documentId().');\n      }\n\n      if (opStr === 'in') {\n        if (!Array.isArray(value) || value.length === 0) {\n          throw new Error(`Invalid Query. A non-empty array is required for '${opStr}' filters.`);\n        }\n\n        value = value.map(el => this.validateReference(el));\n      } else {\n        value = this.validateReference(value);\n      }\n    }\n\n    const fieldFilter = new FieldFilter(this._serializer, path, comparisonOperators[opStr], value);\n\n    const options = this._queryOptions.with({\n      fieldFilters: this._queryOptions.fieldFilters.concat(fieldFilter)\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} instance that applies a\n   * field mask to the result and returns only the specified subset of fields.\n   * You can specify a list of field paths to return, or use an empty list to\n   * only return the references of matching documents.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   * let documentRef = collectionRef.doc('doc');\n   *\n   * return documentRef.set({x:10, y:5}).then(() => {\n   *   return collectionRef.where('x', '>', 5).select('y').get();\n   * }).then((res) => {\n   *   console.log(`y is ${res.docs[0].get('y')}.`);\n   * });\n   */\n\n\n  select(...fieldPaths) {\n    const fields = [];\n\n    if (fieldPaths.length === 0) {\n      fields.push({\n        fieldPath: path_1.FieldPath.documentId().formattedName\n      });\n    } else {\n      for (let i = 0; i < fieldPaths.length; ++i) {\n        path_1.validateFieldPath(i, fieldPaths[i]);\n        fields.push({\n          fieldPath: path_1.FieldPath.fromArgument(fieldPaths[i]).formattedName\n        });\n      }\n    }\n\n    const options = this._queryOptions.with({\n      projection: {\n        fields\n      }\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that's additionally sorted\n   * by the specified field, optionally in descending order instead of\n   * ascending.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {string|FieldPath} fieldPath The field to sort by.\n   * @param {string=} directionStr Optional direction to sort by ('asc' or\n   * 'desc'). If not specified, order will be ascending.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  orderBy(fieldPath, directionStr) {\n    path_1.validateFieldPath('fieldPath', fieldPath);\n    directionStr = validateQueryOrder('directionStr', directionStr);\n\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify an orderBy() constraint after calling ' + 'startAt(), startAfter(), endBefore() or endAt().');\n    }\n\n    const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n\n    const options = this._queryOptions.with({\n      fieldOrders: this._queryOptions.fieldOrders.concat(newOrder)\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that only returns the\n   * first matching documents.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the limit.\n   *\n   * @param {number} limit The maximum number of items to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(1).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  limit(limit) {\n    validate_1.validateInteger('limit', limit);\n\n    const options = this._queryOptions.with({\n      limit,\n      limitType: LimitType.First\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that only returns the\n   * last matching documents.\n   *\n   * You must specify at least one orderBy clause for limitToLast queries,\n   * otherwise an exception will be thrown during execution.\n   *\n   * Results for limitToLast queries cannot be streamed via the `stream()` API.\n   *\n   * @param limit The maximum number of items to return.\n   * @return The created Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limitToLast(1).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  limitToLast(limit) {\n    validate_1.validateInteger('limitToLast', limit);\n\n    const options = this._queryOptions.with({\n      limit,\n      limitType: LimitType.Last\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Specifies the offset of the returned results.\n   *\n   * This function returns a new (immutable) instance of the\n   * [Query]{@link Query} (rather than modify the existing instance)\n   * to impose the offset.\n   *\n   * @param {number} offset The offset to apply to the Query results\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(10).offset(20).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  offset(offset) {\n    validate_1.validateInteger('offset', offset);\n\n    const options = this._queryOptions.with({\n      offset\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Returns true if this `Query` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `Query` is equal to the provided value.\n   */\n\n\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n\n    return other instanceof Query && this._queryOptions.isEqual(other._queryOptions);\n  }\n  /**\n   * Computes the backend ordering semantics for DocumentSnapshot cursors.\n   *\n   * @private\n   * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n   * set of field values to use as the boundary.\n   * @returns The implicit ordering semantics.\n   */\n\n\n  createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n    if (!Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n      return this._queryOptions.fieldOrders;\n    }\n\n    const fieldOrders = this._queryOptions.fieldOrders.slice();\n\n    let hasDocumentId = false;\n\n    if (fieldOrders.length === 0) {\n      // If no explicit ordering is specified, use the first inequality to\n      // define an implicit order.\n      for (const fieldFilter of this._queryOptions.fieldFilters) {\n        if (fieldFilter.isInequalityFilter()) {\n          fieldOrders.push(new FieldOrder(fieldFilter.field));\n          break;\n        }\n      }\n    } else {\n      for (const fieldOrder of fieldOrders) {\n        if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n          hasDocumentId = true;\n        }\n      }\n    }\n\n    if (!hasDocumentId) {\n      // Add implicit sorting by name, using the last specified direction.\n      const lastDirection = fieldOrders.length === 0 ? directionOperators.ASC : fieldOrders[fieldOrders.length - 1].direction;\n      fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n    }\n\n    return fieldOrders;\n  }\n  /**\n   * Builds a Firestore 'Position' proto message.\n   *\n   * @private\n   * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n   * cursor.\n   * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n   * snapshot of the document or the set of field values to use as the boundary.\n   * @param before Whether the query boundary lies just before or after the\n   * provided data.\n   * @returns {Object} The proto message.\n   */\n\n\n  createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n    let fieldValues;\n\n    if (Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n      fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n    } else {\n      fieldValues = cursorValuesOrDocumentSnapshot;\n    }\n\n    if (fieldValues.length > fieldOrders.length) {\n      throw new Error('Too many cursor values specified. The specified ' + 'values must match the orderBy() constraints of the query.');\n    }\n\n    const options = {\n      values: [],\n      before\n    };\n\n    for (let i = 0; i < fieldValues.length; ++i) {\n      let fieldValue = fieldValues[i];\n\n      if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n        fieldValue = this.validateReference(fieldValue);\n      }\n\n      validateQueryValue(i, fieldValue);\n      options.values.push(fieldValue);\n    }\n\n    return options;\n  }\n  /**\n   * Validates that a value used with FieldValue.documentId() is either a\n   * string or a DocumentReference that is part of the query`s result set.\n   * Throws a validation error or returns a DocumentReference that can\n   * directly be used in the Query.\n   *\n   * @param val The value to validate.\n   * @throws If the value cannot be used for this query.\n   * @return If valid, returns a DocumentReference that can be used with the\n   * query.\n   * @private\n   */\n\n\n  validateReference(val) {\n    const basePath = this._queryOptions.allDescendants ? this._queryOptions.parentPath : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    let reference;\n\n    if (typeof val === 'string') {\n      const path = basePath.append(val);\n\n      if (this._queryOptions.allDescendants) {\n        if (!path.isDocument) {\n          throw new Error('When querying a collection group and ordering by ' + 'FieldPath.documentId(), the corresponding value must result in ' + `a valid document path, but '${val}' is not because it ` + 'contains an odd number of segments.');\n        }\n      } else if (val.indexOf('/') !== -1) {\n        throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' + `the corresponding value must be a plain document ID, but '${val}' ` + 'contains a slash.');\n      }\n\n      reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n    } else if (val instanceof DocumentReference) {\n      reference = val;\n\n      if (!basePath.isPrefixOf(reference._path)) {\n        throw new Error(`\"${reference.path}\" is not part of the query result set and ` + 'cannot be used as a query boundary.');\n      }\n    } else {\n      throw new Error('The corresponding value for FieldPath.documentId() must be a ' + `string or a DocumentReference, but was \"${val}\".`);\n    }\n\n    if (!this._queryOptions.allDescendants && reference._path.parent().compareTo(basePath) !== 0) {\n      throw new Error('Only a direct child can be used as a query boundary. ' + `Found: \"${reference.path}\".`);\n    }\n\n    return reference;\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start at or the field values to\n   * start this query at, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  startAt(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.startAt', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts after the\n   * provided set of field values relative to the order of the query. The order\n   * of the provided values must match the order of the order by clauses of the\n   * query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start after or the field values to\n   * start this query after, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  startAfter(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.startAfter', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends before the set of\n   * field values relative to the order of the query. The order of the provided\n   * values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end before or the field values to\n   * end this query before, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  endBefore(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.endBefore', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end at or the field values to end\n   * this query at, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  endAt(...fieldValuesOrDocumentSnapshot) {\n    validate_1.validateMinNumberOfArguments('Query.endAt', arguments, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Executes the query and returns the results as a\n   * [QuerySnapshot]{@link QuerySnapshot}.\n   *\n   * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n   * of the Query.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   */\n\n\n  get() {\n    return this._get();\n  }\n  /**\n   * Internal get() method that accepts an optional transaction id.\n   *\n   * @private\n   * @param {bytes=} transactionId A transaction ID.\n   */\n\n\n  _get(transactionId) {\n    const docs = [];\n    return new Promise((resolve, reject) => {\n      let readTime;\n\n      this._stream(transactionId).on('error', err => {\n        reject(err);\n      }).on('data', result => {\n        readTime = result.readTime;\n\n        if (result.document) {\n          docs.push(result.document);\n        }\n      }).on('end', () => {\n        if (this._queryOptions.limitType === LimitType.Last) {\n          // The results for limitToLast queries need to be flipped since\n          // we reversed the ordering constraints before sending the query\n          // to the backend.\n          docs.reverse();\n        }\n\n        resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n          const changes = [];\n\n          for (let i = 0; i < docs.length; ++i) {\n            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n          }\n\n          return changes;\n        }));\n      });\n    });\n  }\n  /**\n   * Executes the query and streams the results as\n   * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n   *\n   * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n   * QueryDocumentSnapshots.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let count = 0;\n   *\n   * query.stream().on('data', (documentSnapshot) => {\n   *   console.log(`Found document with name '${documentSnapshot.id}'`);\n   *   ++count;\n   * }).on('end', () => {\n   *   console.log(`Total count is ${count}`);\n   * });\n   */\n\n\n  stream() {\n    if (this._queryOptions.limitType === LimitType.Last) {\n      throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.get() instead.');\n    }\n\n    const responseStream = this._stream();\n\n    const transform = through2.obj(function (chunk, encoding, callback) {\n      // Only send chunks with documents.\n      if (chunk.document) {\n        this.push(chunk.document);\n      }\n\n      callback();\n    });\n    responseStream.pipe(transform);\n    responseStream.on('error', transform.destroy);\n    return transform;\n  }\n  /**\n   * Converts a QueryCursor to its proto representation.\n   *\n   * @param cursor The original cursor value\n   * @private\n   */\n\n\n  toCursor(cursor) {\n    if (cursor) {\n      const values = cursor.values.map(val => this._serializer.encodeValue(val));\n      return cursor.before ? {\n        before: true,\n        values\n      } : {\n        values\n      };\n    }\n\n    return undefined;\n  }\n  /**\n   * Internal method for serializing a query to its RunQuery proto\n   * representation with an optional transaction id.\n   *\n   * @param transactionId A transaction ID.\n   * @private\n   * @returns Serialized JSON for the query.\n   */\n\n\n  toProto(transactionId) {\n    const projectId = this.firestore.projectId;\n\n    const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n\n    const reqOpts = {\n      parent: parentPath.formattedName,\n      structuredQuery: {\n        from: [{\n          collectionId: this._queryOptions.collectionId\n        }]\n      }\n    };\n\n    if (this._queryOptions.allDescendants) {\n      reqOpts.structuredQuery.from[0].allDescendants = true;\n    }\n\n    const structuredQuery = reqOpts.structuredQuery;\n\n    if (this._queryOptions.fieldFilters.length === 1) {\n      structuredQuery.where = this._queryOptions.fieldFilters[0].toProto();\n    } else if (this._queryOptions.fieldFilters.length > 1) {\n      const filters = [];\n\n      for (const fieldFilter of this._queryOptions.fieldFilters) {\n        filters.push(fieldFilter.toProto());\n      }\n\n      structuredQuery.where = {\n        compositeFilter: {\n          op: 'AND',\n          filters\n        }\n      };\n    }\n\n    if (this._queryOptions.limitType === LimitType.Last) {\n      if (!this._queryOptions.hasFieldOrders()) {\n        throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n      }\n\n      structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n        // Flip the orderBy directions since we want the last results\n        const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n        return new FieldOrder(order.field, dir).toProto();\n      }); // Swap the cursors to match the now-flipped query ordering.\n\n      structuredQuery.startAt = this._queryOptions.endAt ? this.toCursor({\n        values: this._queryOptions.endAt.values,\n        before: !this._queryOptions.endAt.before\n      }) : undefined;\n      structuredQuery.endAt = this._queryOptions.startAt ? this.toCursor({\n        values: this._queryOptions.startAt.values,\n        before: !this._queryOptions.startAt.before\n      }) : undefined;\n    } else {\n      if (this._queryOptions.hasFieldOrders()) {\n        structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n      }\n\n      structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n      structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n    }\n\n    if (this._queryOptions.limit) {\n      structuredQuery.limit = {\n        value: this._queryOptions.limit\n      };\n    }\n\n    structuredQuery.offset = this._queryOptions.offset;\n    structuredQuery.select = this._queryOptions.projection;\n    reqOpts.transaction = transactionId;\n    return reqOpts;\n  }\n  /**\n   * Internal streaming method that accepts an optional transaction ID.\n   *\n   * @param transactionId A transaction ID.\n   * @private\n   * @returns A stream of document results.\n   */\n\n\n  _stream(transactionId) {\n    const tag = util_1.requestTag();\n    const self = this;\n    const stream = through2.obj(function (proto, enc, callback) {\n      const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n\n      if (proto.document) {\n        const document = self.firestore.snapshot_(proto.document, proto.readTime);\n        const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(self._queryOptions.converter)); // Recreate the QueryDocumentSnapshot with the DocumentReference\n        // containing the original converter.\n\n        finalDoc.fieldsProto = document._fieldsProto;\n        finalDoc.readTime = document.readTime;\n        finalDoc.createTime = document.createTime;\n        finalDoc.updateTime = document.updateTime;\n        this.push({\n          document: finalDoc.build(),\n          readTime\n        });\n      } else {\n        this.push({\n          readTime\n        });\n      }\n\n      callback();\n    });\n    this.firestore.initializeIfNeeded(tag).then(async () => {\n      // `toProto()` might throw an exception. We rely on the behavior of an\n      // async function to convert this exception into the rejected Promise we\n      // catch below.\n      const request = this.toProto(transactionId);\n      return this._firestore.requestStream('runQuery', request, tag);\n    }).then(backendStream => {\n      backendStream.on('error', err => {\n        logger_1.logger('Query._stream', tag, 'Query failed with stream error:', err);\n        stream.destroy(err);\n      });\n      backendStream.resume();\n      backendStream.pipe(stream);\n    }).catch(e => stream.destroy(e));\n    return stream;\n  }\n  /**\n   * Attaches a listener for QuerySnapshot events.\n   *\n   * @param {querySnapshotCallback} onNext A callback to be called every time\n   * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n   * @param {errorCallback=} onError A callback to be called if the listen\n   * fails or is cancelled. No further callbacks will occur.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let unsubscribe = query.onSnapshot(querySnapshot => {\n   *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   */\n\n\n  onSnapshot(onNext, onError) {\n    validate_1.validateFunction('onNext', onNext);\n    validate_1.validateFunction('onError', onError, {\n      optional: true\n    });\n    const watch = new watch_1.QueryWatch(this.firestore, this, this._queryOptions.converter);\n    return watch.onSnapshot((readTime, size, docs, changes) => {\n      onNext(new QuerySnapshot(this, readTime, size, docs, changes));\n    }, onError || console.error);\n  }\n  /**\n   * Returns a function that can be used to sort QueryDocumentSnapshots\n   * according to the sort criteria of this query.\n   *\n   * @private\n   */\n\n\n  comparator() {\n    return (doc1, doc2) => {\n      // Add implicit sorting by name, using the last specified direction.\n      const lastDirection = this._queryOptions.hasFieldOrders() ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction : 'ASCENDING';\n\n      const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n\n      for (const orderBy of orderBys) {\n        let comp;\n\n        if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n          comp = doc1.ref._path.compareTo(doc2.ref._path);\n        } else {\n          const v1 = doc1.protoField(orderBy.field);\n          const v2 = doc2.protoField(orderBy.field);\n\n          if (v1 === undefined || v2 === undefined) {\n            throw new Error('Trying to compare documents on fields that ' + \"don't exist. Please include the fields you are ordering on \" + 'in your select() call.');\n          }\n\n          comp = order_1.compare(v1, v2);\n        }\n\n        if (comp !== 0) {\n          const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n          return direction * comp;\n        }\n      }\n\n      return 0;\n    };\n  }\n  /**\n   * Applies a custom data converter to this Query, allowing you to use your\n   * own custom model objects with Firestore. When you call get() on the\n   * returned Query, the provided converter will convert between Firestore\n   * data and your custom type U.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * @example\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     data: FirebaseFirestore.DocumentData\n   *   ): Post {\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * @param converter Converts objects to and from Firestore.\n   * @return A Query<U> that uses the provided converter.\n   */\n\n\n  withConverter(converter) {\n    return new Query(this.firestore, this._queryOptions.withConverter(converter));\n  }\n\n}\n\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class\n * @extends Query\n */\n\nclass CollectionReference extends Query {\n  /**\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   * @param path The Path of this collection.\n   */\n  constructor(firestore, path, converter) {\n    super(firestore, QueryOptions.forCollectionQuery(path, converter));\n  }\n  /**\n   * Returns a resource path for this collection.\n   * @private\n   */\n\n\n  get resourcePath() {\n    return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n  }\n  /**\n   * The last path element of the referenced collection.\n   *\n   * @type {string}\n   * @name CollectionReference#id\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * console.log(`ID of the subcollection: ${collectionRef.id}`);\n   */\n\n\n  get id() {\n    return this._queryOptions.collectionId;\n  }\n  /**\n   * A reference to the containing Document if this is a subcollection, else\n   * null.\n   *\n   * @type {DocumentReference}\n   * @name CollectionReference#parent\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * let documentRef = collectionRef.parent;\n   * console.log(`Parent name: ${documentRef.path}`);\n   */\n\n\n  get parent() {\n    return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n  }\n  /**\n   * A string representing the path of the referenced collection (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name CollectionReference#path\n   * @readonly\n   *\n   * @example\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * console.log(`Path of the subcollection: ${collectionRef.path}`);\n   */\n\n\n  get path() {\n    return this.resourcePath.relativeName;\n  }\n  /**\n   * Retrieves the list of documents in this collection.\n   *\n   * The document references returned may include references to \"missing\n   * documents\", i.e. document locations that have no document present but\n   * which contain subcollections with documents. Attempting to read such a\n   * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n   * `DocumentSnapshot` whose `.exists` property is false.\n   *\n   * @return {Promise<DocumentReference[]>} The list of documents in this\n   * collection.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   *\n   * return collectionRef.listDocuments().then(documentRefs => {\n   *    return firestore.getAll(documentRefs);\n   * }).then(documentSnapshots => {\n   *    for (let documentSnapshot of documentSnapshots) {\n   *       if (documentSnapshot.exists) {\n   *         console.log(`Found document with data: ${documentSnapshot.id}`);\n   *       } else {\n   *         console.log(`Found missing document: ${documentSnapshot.id}`);\n   *       }\n   *    }\n   * });\n   */\n\n\n  listDocuments() {\n    const tag = util_1.requestTag();\n    return this.firestore.initializeIfNeeded(tag).then(() => {\n      const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId);\n\n      const request = {\n        parent: parentPath.formattedName,\n        collectionId: this.id,\n        showMissing: true,\n        // Setting `pageSize` to the maximum allowed value lets the backend cap\n        // the page size (currently to 300).\n        pageSize: Math.pow(2, 32) - 1,\n        mask: {\n          fieldPaths: []\n        }\n      };\n      return this.firestore.request('listDocuments', request, tag).then(documents => {\n        // Note that the backend already orders these documents by name,\n        // so we do not need to manually sort them.\n        return documents.map(doc => {\n          const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n          return this.doc(path.id);\n        });\n      });\n    });\n  }\n  /**\n   * Gets a [DocumentReference]{@link DocumentReference} instance that\n   * refers to the document at the specified path. If no path is specified, an\n   * automatically-generated unique ID will be used for the returned\n   * DocumentReference.\n   *\n   * @param {string=} documentPath A slash-separated path to a document.\n   * @returns {DocumentReference} The `DocumentReference`\n   * instance.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   * let documentRefWithName = collectionRef.doc('doc');\n   * let documentRefWithAutoId = collectionRef.doc();\n   * console.log(`Reference with name: ${documentRefWithName.path}`);\n   * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n   */\n\n\n  doc(documentPath) {\n    if (arguments.length === 0) {\n      documentPath = util_1.autoId();\n    } else {\n      path_1.validateResourcePath('documentPath', documentPath);\n    }\n\n    const path = this.resourcePath.append(documentPath);\n\n    if (!path.isDocument) {\n      throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n    }\n\n    return new DocumentReference(this.firestore, path, this._queryOptions.converter);\n  }\n  /**\n   * Add a new document to this collection with the specified data, assigning\n   * it a document ID automatically.\n   *\n   * @param {DocumentData} data An Object containing the data for the new\n   * document.\n   * @returns {Promise.<DocumentReference>} A Promise resolved with a\n   * [DocumentReference]{@link DocumentReference} pointing to the\n   * newly created document.\n   *\n   * @example\n   * let collectionRef = firestore.collection('col');\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name: ${documentReference.id}`);\n   * });\n   */\n\n\n  add(data) {\n    const firestoreData = this._queryOptions.converter.toFirestore(data);\n\n    write_batch_1.validateDocumentData('data', firestoreData,\n    /*allowDeletes=*/\n    false);\n    const documentRef = this.doc();\n    return documentRef.create(data).then(() => documentRef);\n  }\n  /**\n   * Returns true if this `CollectionReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `CollectionReference` is equal to the\n   * provided value.\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof CollectionReference && super.isEqual(other);\n  }\n  /**\n   * Applies a custom data converter to this CollectionReference, allowing you\n   * to use your own custom model objects with Firestore. When you call add()\n   * on the returned CollectionReference instance, the provided converter will\n   * convert between Firestore data and your custom type U.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * @example\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     data: FirebaseFirestore.DocumentData\n   *   ): Post {\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * @param converter Converts objects to and from Firestore.\n   * @return A CollectionReference<U> that uses the provided converter.\n   */\n\n\n  withConverter(converter) {\n    return new CollectionReference(this.firestore, this.resourcePath, converter);\n  }\n\n}\n\nexports.CollectionReference = CollectionReference;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\n\nfunction validateQueryOrder(arg, op) {\n  // For backwards compatibility, we support both lower and uppercase values.\n  op = typeof op === 'string' ? op.toLowerCase() : op;\n  validate_1.validateEnumValue(arg, op, Object.keys(directionOperators), {\n    optional: true\n  });\n  return op;\n}\n\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\n\nfunction validateQueryOperator(arg, op, fieldValue) {\n  // For backwards compatibility, we support both `=` and `==` for \"equals\".\n  op = op === '=' ? '==' : op;\n  validate_1.validateEnumValue(arg, op, Object.keys(comparisonOperators));\n\n  if (typeof fieldValue === 'number' && isNaN(fieldValue) && op !== '==') {\n    throw new Error('Invalid query. You can only perform equals comparisons on NaN.');\n  }\n\n  if (fieldValue === null && op !== '==') {\n    throw new Error('Invalid query. You can only perform equals comparisons on Null.');\n  }\n\n  return op;\n}\n\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n */\n\nfunction validateDocumentReference(arg, value) {\n  if (!(value instanceof DocumentReference)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentReference'));\n  }\n}\n\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n */\n\nfunction validateQueryValue(arg, value) {\n  serializer_1.validateUserInput(arg, value, 'query constraint', {\n    allowDeletes: 'none',\n    allowTransforms: false\n  });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\n\n\nfunction isArrayEqual(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; ++i) {\n    if (!left[i].isEqual(right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n */\n\n\nfunction coalesce(...values) {\n  return values.find(value => value !== undefined);\n}","map":{"version":3,"sources":["/Users/vedadnya_98/Downloads/CS-554-master 2/react_third_lecture/firebase-auth/node_modules/@google-cloud/firestore/build/src/reference.js"],"names":["Object","defineProperty","exports","value","deepEqual","require","through2","document_1","document_change_1","logger_1","order_1","path_1","serializer_1","timestamp_1","types_1","util_1","validate_1","watch_1","write_batch_1","directionOperators","asc","desc","comparisonOperators","in","DocumentReference","constructor","_firestore","_path","_converter","defaultConverter","formattedName","projectId","firestore","toQualifiedResourcePath","path","relativeName","id","parent","CollectionReference","get","getAll","then","result","collection","collectionPath","validateResourcePath","append","isCollection","Error","listCollections","tag","requestTag","initializeIfNeeded","request","pageSize","Math","pow","collectionIds","collections","sort","collectionId","push","create","data","writeBatch","WriteBatch","commit","writeResult","delete","precondition","set","options","update","dataOrField","preconditionOrValues","validateMinNumberOfArguments","arguments","onSnapshot","onNext","onError","validateFunction","optional","watch","DocumentWatch","readTime","size","docs","document","ref","DocumentSnapshotBuilder","build","console","error","isEqual","other","toProto","referenceValue","withConverter","converter","FieldOrder","field","direction","fieldPath","FieldFilter","serializer","op","isInequalityFilter","isNaN","unaryFilter","fieldFilter","encodeValue","QuerySnapshot","_query","_readTime","_size","changes","_materializedDocs","_materializedChanges","_docs","_changes","query","empty","docChanges","forEach","callback","thisArg","doc","call","isArrayEqual","throwDocChangesMethodError","docChangesPropertiesToOverride","Symbol","iterator","property","prototype","LimitType","QueryOptions","parentPath","allDescendants","fieldFilters","fieldOrders","startAt","endAt","limit","limitType","offset","projection","forCollectionGroupQuery","ResourcePath","EMPTY","forCollectionQuery","collectionRef","with","settings","coalesce","hasFieldOrders","length","strict","Query","_queryOptions","_serializer","Serializer","_isDocumentSnapshot","fieldValuesOrDocumentSnapshot","DocumentSnapshot","_extractFieldValues","documentSnapshot","fieldValues","fieldOrder","FieldPath","documentId","fieldValue","undefined","where","opStr","validateFieldPath","validateQueryOperator","validateQueryValue","fromArgument","Array","isArray","map","el","validateReference","concat","select","fieldPaths","fields","i","orderBy","directionStr","validateQueryOrder","newOrder","validateInteger","First","limitToLast","Last","createImplicitOrderBy","cursorValuesOrDocumentSnapshot","slice","hasDocumentId","lastDirection","ASC","createCursor","before","values","val","basePath","reference","isDocument","indexOf","isPrefixOf","compareTo","startAfter","endBefore","_get","transactionId","Promise","resolve","reject","_stream","on","err","reverse","DocumentChange","stream","responseStream","transform","obj","chunk","encoding","pipe","destroy","toCursor","cursor","reqOpts","structuredQuery","from","filters","compositeFilter","order","dir","o","transaction","self","proto","enc","Timestamp","fromProto","snapshot_","finalDoc","fieldsProto","_fieldsProto","createTime","updateTime","requestStream","backendStream","logger","resume","catch","e","QueryWatch","comparator","doc1","doc2","orderBys","comp","v1","protoField","v2","compare","resourcePath","listDocuments","showMissing","mask","documents","QualifiedResourcePath","fromSlashSeparatedString","name","documentPath","autoId","add","firestoreData","toFirestore","validateDocumentData","documentRef","arg","toLowerCase","validateEnumValue","keys","validateDocumentReference","invalidArgumentMessage","validateUserInput","allowDeletes","allowTransforms","left","right","find"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst deepEqual = require('deep-equal');\nconst through2 = require(\"through2\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst order_1 = require(\"./order\");\nconst path_1 = require(\"./path\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst watch_1 = require(\"./watch\");\nconst write_batch_1 = require(\"./write-batch\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n */\nconst directionOperators = {\n    asc: 'ASCENDING',\n    desc: 'DESCENDING',\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '>=', '>', 'array-contains', 'in', and\n * 'array-contains-any'.\n *\n * @private\n */\nconst comparisonOperators = {\n    '<': 'LESS_THAN',\n    '<=': 'LESS_THAN_OR_EQUAL',\n    '==': 'EQUAL',\n    '>': 'GREATER_THAN',\n    '>=': 'GREATER_THAN_OR_EQUAL',\n    'array-contains': 'ARRAY_CONTAINS',\n    in: 'IN',\n    'array-contains-any': 'ARRAY_CONTAINS_ANY',\n};\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class\n */\nclass DocumentReference {\n    /**\n     * @hideconstructor\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _path The Path of this reference.\n     */\n    constructor(_firestore, _path, _converter = types_1.defaultConverter) {\n        this._firestore = _firestore;\n        this._path = _path;\n        this._converter = _converter;\n    }\n    /**\n     * The string representation of the DocumentReference's location.\n     * @private\n     * @type {string}\n     * @name DocumentReference#formattedName\n     */\n    get formattedName() {\n        const projectId = this.firestore.projectId;\n        return this._path.toQualifiedResourcePath(projectId).formattedName;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name DocumentReference#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name DocumentReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document at '${documentReference.path}'`);\n     * });\n     */\n    get path() {\n        return this._path.relativeName;\n    }\n    /**\n     * The last path element of the referenced document.\n     *\n     * @type {string}\n     * @name DocumentReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name '${documentReference.id}'`);\n     * });\n     */\n    get id() {\n        return this._path.id;\n    }\n    /**\n     * A reference to the collection to which this DocumentReference belongs.\n     *\n     * @name DocumentReference#parent\n     * @type {CollectionReference}\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let collectionRef = documentRef.parent;\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\n     *   console.log(`Found ${results.size} matches in parent collection`);\n     * }):\n     */\n    get parent() {\n        return new CollectionReference(this._firestore, this._path.parent(), this._converter);\n    }\n    /**\n     * Reads the document referred to by this DocumentReference.\n     *\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n     * DocumentSnapshot for the retrieved document on success. For missing\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\n     * other reasons, the Promise will be rejected.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log('Document retrieved successfully.');\n     *   }\n     * });\n     */\n    get() {\n        return this._firestore.getAll(this).then(([result]) => result);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} A reference to the new\n     * subcollection.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let subcollection = documentRef.collection('subcollection');\n     * console.log(`Path to subcollection: ${subcollection.path}`);\n     */\n    collection(collectionPath) {\n        path_1.validateResourcePath('collectionPath', collectionPath);\n        const path = this._path.append(collectionPath);\n        if (!path.isCollection) {\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n        }\n        return new CollectionReference(this._firestore, path);\n    }\n    /**\n     * Fetches the subcollections that are direct children of this document.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found subcollection with id: ${collection.id}`);\n     *   }\n     * });\n     */\n    listCollections() {\n        const tag = util_1.requestTag();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const request = {\n                parent: this.formattedName,\n                // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                // the page size (currently to 300). Note that the backend rejects\n                // MAX_INT32 (b/146883794).\n                pageSize: Math.pow(2, 16) - 1,\n            };\n            return this._firestore\n                .request('listCollectionIds', request, tag)\n                .then(collectionIds => {\n                const collections = [];\n                // We can just sort this list using the default comparator since it\n                // will only contain collection ids.\n                collectionIds.sort();\n                for (const collectionId of collectionIds) {\n                    collections.push(this.collection(collectionId));\n                }\n                return collections;\n            });\n        });\n    }\n    /**\n     * Create a document with the provided object values. This will fail the write\n     * if a document exists at its location.\n     *\n     * @param {DocumentData} data An object that contains the fields and data to\n     * serialize as the document.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this create.\n     *\n     * @example\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * documentRef.create({foo: 'bar'}).then((res) => {\n     *   console.log(`Document created at ${res.updateTime}`);\n     * }).catch((err) => {\n     *   console.log(`Failed to create document: ${err}`);\n     * });\n     */\n    create(data) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .create(this, data)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Deletes the document referred to by this `DocumentReference`.\n     *\n     * A delete for a non-existing document is treated as a success (unless\n     * lastUptimeTime is provided).\n     *\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the delete if the\n     * document was last updated at a different time.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * delete time.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.delete().then(() => {\n     *   console.log('Document successfully deleted.');\n     * });\n     */\n    delete(precondition) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .delete(this, precondition)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Writes to the document referred to by this DocumentReference. If the\n     * document does not yet exist, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n     * existing document.\n     *\n     * @param {T} data A map of the fields and values for the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge If true, set() merges the values specified\n     * in its data argument. Fields omitted from this set() call remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this set.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(res => {\n     *   console.log(`Document written at ${res.updateTime}`);\n     * });\n     */\n    set(data, options) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .set(this, data, options)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Updates fields in the document referred to by this DocumentReference.\n     * If the document doesn't yet exist, the update fails and the returned\n     * Promise will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n     * list of field paths and values to update or a Precondition to restrict\n     * this update.\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\n     * data has been successfully written to the backend.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update({foo: 'bar'}).then(res => {\n     *   console.log(`Document updated at ${res.updateTime}`);\n     * });\n     */\n    update(dataOrField, ...preconditionOrValues) {\n        validate_1.validateMinNumberOfArguments('DocumentReference.update', arguments, 1);\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .update(this, dataOrField, ...preconditionOrValues)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Attaches a listener for DocumentSnapshot events.\n     *\n     * @param {documentSnapshotCallback} onNext A callback to be called every\n     * time a new `DocumentSnapshot` is available.\n     * @param {errorCallback=} onError A callback to be called if the listen fails\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\n     * logged to the console.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(documentSnapshot.data());\n     *   }\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    onSnapshot(onNext, onError) {\n        validate_1.validateFunction('onNext', onNext);\n        validate_1.validateFunction('onError', onError, { optional: true });\n        const watch = new watch_1.DocumentWatch(this.firestore, this);\n        return watch.onSnapshot((readTime, size, docs) => {\n            for (const document of docs()) {\n                if (document.ref.path === this.path) {\n                    onNext(document);\n                    return;\n                }\n            }\n            // The document is missing.\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\n            const document = new document_1.DocumentSnapshotBuilder(ref);\n            document.readTime = readTime;\n            onNext(document.build());\n        }, onError || console.error);\n    }\n    /**\n     * Returns true if this `DocumentReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof DocumentReference &&\n                this._firestore === other._firestore &&\n                this._path.isEqual(other._path) &&\n                this._converter === other._converter));\n    }\n    /**\n     * Converts this DocumentReference to the Firestore Proto representation.\n     *\n     * @private\n     */\n    toProto() {\n        return { referenceValue: this.formattedName };\n    }\n    /**\n     * Applies a custom data converter to this DocumentReference, allowing you\n     * to use your own custom model objects with Firestore. When you call\n     * set(), get(), etc. on the returned DocumentReference instance, the\n     * provided converter will convert between Firestore data and your custom\n     * type U.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * @example\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     data: FirebaseFirestore.DocumentData\n     *   ): Post {\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * @param converter Converts objects to and from Firestore.\n     * @return A DocumentReference<U> that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, this._path, converter);\n    }\n}\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @class\n */\nclass FieldOrder {\n    /**\n     * @param field The name of a document field (member) on which to order query\n     * results.\n     * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n     * set the ordering direction to ascending or descending, respectively.\n     */\n    constructor(field, direction = 'ASCENDING') {\n        this.field = field;\n        this.direction = direction;\n    }\n    /**\n     * Generates the proto representation for this field order.\n     * @private\n     */\n    toProto() {\n        return {\n            field: {\n                fieldPath: this.field.formattedName,\n            },\n            direction: this.direction,\n        };\n    }\n}\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @class\n */\nclass FieldFilter {\n    /**\n     * @param serializer The Firestore serializer\n     * @param field The path of the property value to compare.\n     * @param op A comparison operation.\n     * @param value The value to which to compare the field for inclusion in a\n     * query.\n     */\n    constructor(serializer, field, op, value) {\n        this.serializer = serializer;\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Returns whether this FieldFilter uses an equals comparison.\n     *\n     * @private\n     */\n    isInequalityFilter() {\n        switch (this.op) {\n            case 'GREATER_THAN':\n            case 'GREATER_THAN_OR_EQUAL':\n            case 'LESS_THAN':\n            case 'LESS_THAN_OR_EQUAL':\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Generates the proto representation for this field filter.\n     *\n     * @private\n     */\n    toProto() {\n        if (typeof this.value === 'number' && isNaN(this.value)) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: 'IS_NAN',\n                },\n            };\n        }\n        if (this.value === null) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: 'IS_NULL',\n                },\n            };\n        }\n        return {\n            fieldFilter: {\n                field: {\n                    fieldPath: this.field.formattedName,\n                },\n                op: this.op,\n                value: this.serializer.encodeValue(this.value),\n            },\n        };\n    }\n}\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\nclass QuerySnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param _query The originating query.\n     * @param _readTime The time when this query snapshot was obtained.\n     * @param _size The number of documents in the result set.\n     * @param docs A callback returning a sorted array of documents matching\n     * this query\n     * @param changes A callback returning a sorted array of document change\n     * events for this snapshot.\n     */\n    constructor(_query, _readTime, _size, docs, changes) {\n        this._query = _query;\n        this._readTime = _readTime;\n        this._size = _size;\n        this._materializedDocs = null;\n        this._materializedChanges = null;\n        this._docs = null;\n        this._changes = null;\n        this._docs = docs;\n        this._changes = changes;\n    }\n    /**\n     * The query on which you called get() or onSnapshot() in order to get this\n     * QuerySnapshot.\n     *\n     * @type {Query}\n     * @name QuerySnapshot#query\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.limit(10).get().then(querySnapshot => {\n     *   console.log(`Returned first batch of results`);\n     *   let query = querySnapshot.query;\n     *   return query.offset(10).get();\n     * }).then(() => {\n     *   console.log(`Returned second batch of results`);\n     * });\n     */\n    get query() {\n        return this._query;\n    }\n    /**\n     * An array of all the documents in this QuerySnapshot.\n     *\n     * @type {Array.<QueryDocumentSnapshot>}\n     * @name QuerySnapshot#docs\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   let docs = querySnapshot.docs;\n     *   for (let doc of docs) {\n     *     console.log(`Document found at path: ${doc.ref.path}`);\n     *   }\n     * });\n     */\n    get docs() {\n        if (this._materializedDocs) {\n            return this._materializedDocs;\n        }\n        this._materializedDocs = this._docs();\n        this._docs = null;\n        return this._materializedDocs;\n    }\n    /**\n     * True if there are no documents in the QuerySnapshot.\n     *\n     * @type {boolean}\n     * @name QuerySnapshot#empty\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   if (querySnapshot.empty) {\n     *     console.log('No documents found.');\n     *   }\n     * });\n     */\n    get empty() {\n        return this._size === 0;\n    }\n    /**\n     * The number of documents in the QuerySnapshot.\n     *\n     * @type {number}\n     * @name QuerySnapshot#size\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   console.log(`Found ${querySnapshot.size} documents.`);\n     * });\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The time this query snapshot was obtained.\n     *\n     * @type {Timestamp}\n     * @name QuerySnapshot#readTime\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then((querySnapshot) => {\n     *   let readTime = querySnapshot.readTime;\n     *   console.log(`Query results returned at '${readTime.toDate()}'`);\n     * });\n     */\n    get readTime() {\n        return this._readTime;\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If\n     * this is the first snapshot, all documents will be in the list as added\n     * changes.\n     *\n     * @return {Array.<DocumentChange>}\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.onSnapshot(querySnapshot => {\n     *   let changes = querySnapshot.docChanges();\n     *   for (let change of changes) {\n     *     console.log(`A document was ${change.type}.`);\n     *   }\n     * });\n     */\n    docChanges() {\n        if (this._materializedChanges) {\n            return this._materializedChanges;\n        }\n        this._materializedChanges = this._changes();\n        this._changes = null;\n        return this._materializedChanges;\n    }\n    /**\n     * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n     * method for running the same callback on each {@link QueryDocumentSnapshot}\n     * that is returned.\n     *\n     * @param {function} callback A callback to be called with a\n     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n     * the snapshot.\n     * @param {*=} thisArg The `this` binding for the callback..\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    forEach(callback, thisArg) {\n        validate_1.validateFunction('callback', callback);\n        for (const doc of this.docs) {\n            callback.call(thisArg, doc);\n        }\n    }\n    /**\n     * Returns true if the document data in this `QuerySnapshot` is equal to the\n     * provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every query read, we explicitly\n        // ignore all metadata in this comparison.\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof QuerySnapshot)) {\n            return false;\n        }\n        if (this._size !== other._size) {\n            return false;\n        }\n        if (!this._query.isEqual(other._query)) {\n            return false;\n        }\n        if (this._materializedDocs && !this._materializedChanges) {\n            // If we have only materialized the documents, we compare them first.\n            return (isArrayEqual(this.docs, other.docs) &&\n                isArrayEqual(this.docChanges(), other.docChanges()));\n        }\n        // Otherwise, we compare the changes first as we expect there to be fewer.\n        return (isArrayEqual(this.docChanges(), other.docChanges()) &&\n            isArrayEqual(this.docs, other.docs));\n    }\n}\nexports.QuerySnapshot = QuerySnapshot;\n// TODO: As of v0.17.0, we're changing docChanges from an array into a method.\n// Because this is a runtime breaking change and somewhat subtle (both Array and\n// Function have a .length, etc.), we'll replace commonly-used properties\n// (including Symbol.iterator) to throw a custom error message. By our v1.0\n// release, we should remove this code.\nfunction throwDocChangesMethodError() {\n    throw new Error('QuerySnapshot.docChanges has been changed from a property into a ' +\n        'method, so usages like \"querySnapshot.docChanges\" should become ' +\n        '\"querySnapshot.docChanges()\"');\n}\nconst docChangesPropertiesToOverride = [\n    'length',\n    'forEach',\n    'map',\n    ...(typeof Symbol !== 'undefined' ? [Symbol.iterator] : []),\n];\ndocChangesPropertiesToOverride.forEach(property => {\n    Object.defineProperty(QuerySnapshot.prototype.docChanges, property, {\n        get: () => throwDocChangesMethodError(),\n    });\n});\n/*!\n * Denotes whether a provided limit is applied to the beginning or the end of\n * the result set.\n */\nvar LimitType;\n(function (LimitType) {\n    LimitType[LimitType[\"First\"] = 0] = \"First\";\n    LimitType[LimitType[\"Last\"] = 1] = \"Last\";\n})(LimitType || (LimitType = {}));\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n */\nclass QueryOptions {\n    constructor(parentPath, collectionId, converter, allDescendants, fieldFilters, fieldOrders, startAt, endAt, limit, limitType, offset, projection) {\n        this.parentPath = parentPath;\n        this.collectionId = collectionId;\n        this.converter = converter;\n        this.allDescendants = allDescendants;\n        this.fieldFilters = fieldFilters;\n        this.fieldOrders = fieldOrders;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.offset = offset;\n        this.projection = projection;\n    }\n    /**\n     * Returns query options for a collection group query.\n     * @private\n     */\n    static forCollectionGroupQuery(collectionId, converter = types_1.defaultConverter) {\n        return new QueryOptions(\n        /*parentPath=*/ path_1.ResourcePath.EMPTY, collectionId, converter, \n        /*allDescendants=*/ true, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns query options for a single-collection query.\n     * @private\n     */\n    static forCollectionQuery(collectionRef, converter = types_1.defaultConverter) {\n        return new QueryOptions(collectionRef.parent(), collectionRef.id, converter, \n        /*allDescendants=*/ false, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns the union of the current and the provided options.\n     * @private\n     */\n    with(settings) {\n        return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.fieldFilters, this.fieldFilters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection));\n    }\n    withConverter(converter) {\n        return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.fieldFilters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);\n    }\n    hasFieldOrders() {\n        return this.fieldOrders.length > 0;\n    }\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof QueryOptions &&\n            this.parentPath.isEqual(other.parentPath) &&\n            this.collectionId === other.collectionId &&\n            this.converter === other.converter &&\n            this.allDescendants === other.allDescendants &&\n            this.limit === other.limit &&\n            this.offset === other.offset &&\n            deepEqual(this.fieldFilters, other.fieldFilters, { strict: true }) &&\n            deepEqual(this.fieldOrders, other.fieldOrders, { strict: true }) &&\n            deepEqual(this.startAt, other.startAt, { strict: true }) &&\n            deepEqual(this.endAt, other.endAt, { strict: true }) &&\n            deepEqual(this.projection, other.projection, { strict: true }));\n    }\n}\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\nclass Query {\n    /**\n     * @hideconstructor\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _queryOptions Options that define the query.\n     */\n    constructor(_firestore, _queryOptions) {\n        this._firestore = _firestore;\n        this._queryOptions = _queryOptions;\n        this._serializer = new serializer_1.Serializer(_firestore);\n    }\n    /**\n     * Detects the argument type for Firestore cursors.\n     *\n     * @private\n     * @param fieldValuesOrDocumentSnapshot A snapshot of the document or a set\n     * of field values.\n     * @returns 'true' if the input is a single DocumentSnapshot..\n     */\n    static _isDocumentSnapshot(fieldValuesOrDocumentSnapshot) {\n        return (fieldValuesOrDocumentSnapshot.length === 1 &&\n            fieldValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot);\n    }\n    /**\n     * Extracts field values from the DocumentSnapshot based on the provided\n     * field order.\n     *\n     * @private\n     * @param documentSnapshot The document to extract the fields from.\n     * @param fieldOrders The field order that defines what fields we should\n     * extract.\n     * @return {Array.<*>} The field values to use.\n     * @private\n     */\n    static _extractFieldValues(documentSnapshot, fieldOrders) {\n        const fieldValues = [];\n        for (const fieldOrder of fieldOrders) {\n            if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                fieldValues.push(documentSnapshot.ref);\n            }\n            else {\n                const fieldValue = documentSnapshot.get(fieldOrder.field);\n                if (fieldValue === undefined) {\n                    throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` +\n                        'Please provide a document that contains values for all specified ' +\n                        'orderBy() and where() constraints.');\n                }\n                else {\n                    fieldValues.push(fieldValue);\n                }\n            }\n        }\n        return fieldValues;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name Query#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} with the additional filter\n     * that documents must contain the specified field and that its value should\n     * satisfy the relation constraint provided.\n     *\n     * Returns a new Query that constrains the value of a Document property.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the filter.\n     *\n     * @param {string|FieldPath} fieldPath The name of a property value to compare.\n     * @param {string} opStr A comparison operation in the form of a string\n     * (e.g., \"<\").\n     * @param {*} value The value to which to compare the field for inclusion in\n     * a query.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    where(fieldPath, opStr, value) {\n        path_1.validateFieldPath('fieldPath', fieldPath);\n        opStr = validateQueryOperator('opStr', opStr, value);\n        validateQueryValue('value', value);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify a where() filter after calling startAt(), ' +\n                'startAfter(), endBefore() or endAt().');\n        }\n        const path = path_1.FieldPath.fromArgument(fieldPath);\n        if (path_1.FieldPath.documentId().isEqual(path)) {\n            if (opStr === 'array-contains' || opStr === 'array-contains-any') {\n                throw new Error(`Invalid Query. You can't perform '${opStr}' ` +\n                    'queries on FieldPath.documentId().');\n            }\n            if (opStr === 'in') {\n                if (!Array.isArray(value) || value.length === 0) {\n                    throw new Error(`Invalid Query. A non-empty array is required for '${opStr}' filters.`);\n                }\n                value = value.map(el => this.validateReference(el));\n            }\n            else {\n                value = this.validateReference(value);\n            }\n        }\n        const fieldFilter = new FieldFilter(this._serializer, path, comparisonOperators[opStr], value);\n        const options = this._queryOptions.with({\n            fieldFilters: this._queryOptions.fieldFilters.concat(fieldFilter),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} instance that applies a\n     * field mask to the result and returns only the specified subset of fields.\n     * You can specify a list of field paths to return, or use an empty list to\n     * only return the references of matching documents.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRef = collectionRef.doc('doc');\n     *\n     * return documentRef.set({x:10, y:5}).then(() => {\n     *   return collectionRef.where('x', '>', 5).select('y').get();\n     * }).then((res) => {\n     *   console.log(`y is ${res.docs[0].get('y')}.`);\n     * });\n     */\n    select(...fieldPaths) {\n        const fields = [];\n        if (fieldPaths.length === 0) {\n            fields.push({ fieldPath: path_1.FieldPath.documentId().formattedName });\n        }\n        else {\n            for (let i = 0; i < fieldPaths.length; ++i) {\n                path_1.validateFieldPath(i, fieldPaths[i]);\n                fields.push({\n                    fieldPath: path_1.FieldPath.fromArgument(fieldPaths[i]).formattedName,\n                });\n            }\n        }\n        const options = this._queryOptions.with({ projection: { fields } });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that's additionally sorted\n     * by the specified field, optionally in descending order instead of\n     * ascending.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {string|FieldPath} fieldPath The field to sort by.\n     * @param {string=} directionStr Optional direction to sort by ('asc' or\n     * 'desc'). If not specified, order will be ascending.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    orderBy(fieldPath, directionStr) {\n        path_1.validateFieldPath('fieldPath', fieldPath);\n        directionStr = validateQueryOrder('directionStr', directionStr);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify an orderBy() constraint after calling ' +\n                'startAt(), startAfter(), endBefore() or endAt().');\n        }\n        const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n        const options = this._queryOptions.with({\n            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * first matching documents.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the limit.\n     *\n     * @param {number} limit The maximum number of items to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    limit(limit) {\n        validate_1.validateInteger('limit', limit);\n        const options = this._queryOptions.with({\n            limit,\n            limitType: LimitType.First,\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * last matching documents.\n     *\n     * You must specify at least one orderBy clause for limitToLast queries,\n     * otherwise an exception will be thrown during execution.\n     *\n     * Results for limitToLast queries cannot be streamed via the `stream()` API.\n     *\n     * @param limit The maximum number of items to return.\n     * @return The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limitToLast(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    limitToLast(limit) {\n        validate_1.validateInteger('limitToLast', limit);\n        const options = this._queryOptions.with({ limit, limitType: LimitType.Last });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Specifies the offset of the returned results.\n     *\n     * This function returns a new (immutable) instance of the\n     * [Query]{@link Query} (rather than modify the existing instance)\n     * to impose the offset.\n     *\n     * @param {number} offset The offset to apply to the Query results\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(10).offset(20).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    offset(offset) {\n        validate_1.validateInteger('offset', offset);\n        const options = this._queryOptions.with({ offset });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Returns true if this `Query` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `Query` is equal to the provided value.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof Query && this._queryOptions.isEqual(other._queryOptions));\n    }\n    /**\n     * Computes the backend ordering semantics for DocumentSnapshot cursors.\n     *\n     * @private\n     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n     * set of field values to use as the boundary.\n     * @returns The implicit ordering semantics.\n     */\n    createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n        if (!Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n            return this._queryOptions.fieldOrders;\n        }\n        const fieldOrders = this._queryOptions.fieldOrders.slice();\n        let hasDocumentId = false;\n        if (fieldOrders.length === 0) {\n            // If no explicit ordering is specified, use the first inequality to\n            // define an implicit order.\n            for (const fieldFilter of this._queryOptions.fieldFilters) {\n                if (fieldFilter.isInequalityFilter()) {\n                    fieldOrders.push(new FieldOrder(fieldFilter.field));\n                    break;\n                }\n            }\n        }\n        else {\n            for (const fieldOrder of fieldOrders) {\n                if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                    hasDocumentId = true;\n                }\n            }\n        }\n        if (!hasDocumentId) {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = fieldOrders.length === 0\n                ? directionOperators.ASC\n                : fieldOrders[fieldOrders.length - 1].direction;\n            fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n        }\n        return fieldOrders;\n    }\n    /**\n     * Builds a Firestore 'Position' proto message.\n     *\n     * @private\n     * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n     * cursor.\n     * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n     * snapshot of the document or the set of field values to use as the boundary.\n     * @param before Whether the query boundary lies just before or after the\n     * provided data.\n     * @returns {Object} The proto message.\n     */\n    createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n        let fieldValues;\n        if (Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n        }\n        else {\n            fieldValues = cursorValuesOrDocumentSnapshot;\n        }\n        if (fieldValues.length > fieldOrders.length) {\n            throw new Error('Too many cursor values specified. The specified ' +\n                'values must match the orderBy() constraints of the query.');\n        }\n        const options = { values: [], before };\n        for (let i = 0; i < fieldValues.length; ++i) {\n            let fieldValue = fieldValues[i];\n            if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n                fieldValue = this.validateReference(fieldValue);\n            }\n            validateQueryValue(i, fieldValue);\n            options.values.push(fieldValue);\n        }\n        return options;\n    }\n    /**\n     * Validates that a value used with FieldValue.documentId() is either a\n     * string or a DocumentReference that is part of the query`s result set.\n     * Throws a validation error or returns a DocumentReference that can\n     * directly be used in the Query.\n     *\n     * @param val The value to validate.\n     * @throws If the value cannot be used for this query.\n     * @return If valid, returns a DocumentReference that can be used with the\n     * query.\n     * @private\n     */\n    validateReference(val) {\n        const basePath = this._queryOptions.allDescendants\n            ? this._queryOptions.parentPath\n            : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n        let reference;\n        if (typeof val === 'string') {\n            const path = basePath.append(val);\n            if (this._queryOptions.allDescendants) {\n                if (!path.isDocument) {\n                    throw new Error('When querying a collection group and ordering by ' +\n                        'FieldPath.documentId(), the corresponding value must result in ' +\n                        `a valid document path, but '${val}' is not because it ` +\n                        'contains an odd number of segments.');\n                }\n            }\n            else if (val.indexOf('/') !== -1) {\n                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' +\n                    `the corresponding value must be a plain document ID, but '${val}' ` +\n                    'contains a slash.');\n            }\n            reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n        }\n        else if (val instanceof DocumentReference) {\n            reference = val;\n            if (!basePath.isPrefixOf(reference._path)) {\n                throw new Error(`\"${reference.path}\" is not part of the query result set and ` +\n                    'cannot be used as a query boundary.');\n            }\n        }\n        else {\n            throw new Error('The corresponding value for FieldPath.documentId() must be a ' +\n                `string or a DocumentReference, but was \"${val}\".`);\n        }\n        if (!this._queryOptions.allDescendants &&\n            reference._path.parent().compareTo(basePath) !== 0) {\n            throw new Error('Only a direct child can be used as a query boundary. ' +\n                `Found: \"${reference.path}\".`);\n        }\n        return reference;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start at or the field values to\n     * start this query at, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    startAt(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.startAt', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts after the\n     * provided set of field values relative to the order of the query. The order\n     * of the provided values must match the order of the order by clauses of the\n     * query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start after or the field values to\n     * start this query after, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    startAfter(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.startAfter', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends before the set of\n     * field values relative to the order of the query. The order of the provided\n     * values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end before or the field values to\n     * end this query before, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    endBefore(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.endBefore', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end at or the field values to end\n     * this query at, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    endAt(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.endAt', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Executes the query and returns the results as a\n     * [QuerySnapshot]{@link QuerySnapshot}.\n     *\n     * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n     * of the Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    get() {\n        return this._get();\n    }\n    /**\n     * Internal get() method that accepts an optional transaction id.\n     *\n     * @private\n     * @param {bytes=} transactionId A transaction ID.\n     */\n    _get(transactionId) {\n        const docs = [];\n        return new Promise((resolve, reject) => {\n            let readTime;\n            this._stream(transactionId)\n                .on('error', err => {\n                reject(err);\n            })\n                .on('data', result => {\n                readTime = result.readTime;\n                if (result.document) {\n                    docs.push(result.document);\n                }\n            })\n                .on('end', () => {\n                if (this._queryOptions.limitType === LimitType.Last) {\n                    // The results for limitToLast queries need to be flipped since\n                    // we reversed the ordering constraints before sending the query\n                    // to the backend.\n                    docs.reverse();\n                }\n                resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n                    const changes = [];\n                    for (let i = 0; i < docs.length; ++i) {\n                        changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n                    }\n                    return changes;\n                }));\n            });\n        });\n    }\n    /**\n     * Executes the query and streams the results as\n     * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n     *\n     * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n     * QueryDocumentSnapshots.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.stream().on('data', (documentSnapshot) => {\n     *   console.log(`Found document with name '${documentSnapshot.id}'`);\n     *   ++count;\n     * }).on('end', () => {\n     *   console.log(`Total count is ${count}`);\n     * });\n     */\n    stream() {\n        if (this._queryOptions.limitType === LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.get() instead.');\n        }\n        const responseStream = this._stream();\n        const transform = through2.obj(function (chunk, encoding, callback) {\n            // Only send chunks with documents.\n            if (chunk.document) {\n                this.push(chunk.document);\n            }\n            callback();\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', transform.destroy);\n        return transform;\n    }\n    /**\n     * Converts a QueryCursor to its proto representation.\n     *\n     * @param cursor The original cursor value\n     * @private\n     */\n    toCursor(cursor) {\n        if (cursor) {\n            const values = cursor.values.map(val => this._serializer.encodeValue(val));\n            return cursor.before ? { before: true, values } : { values };\n        }\n        return undefined;\n    }\n    /**\n     * Internal method for serializing a query to its RunQuery proto\n     * representation with an optional transaction id.\n     *\n     * @param transactionId A transaction ID.\n     * @private\n     * @returns Serialized JSON for the query.\n     */\n    toProto(transactionId) {\n        const projectId = this.firestore.projectId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n        const reqOpts = {\n            parent: parentPath.formattedName,\n            structuredQuery: {\n                from: [\n                    {\n                        collectionId: this._queryOptions.collectionId,\n                    },\n                ],\n            },\n        };\n        if (this._queryOptions.allDescendants) {\n            reqOpts.structuredQuery.from[0].allDescendants = true;\n        }\n        const structuredQuery = reqOpts.structuredQuery;\n        if (this._queryOptions.fieldFilters.length === 1) {\n            structuredQuery.where = this._queryOptions.fieldFilters[0].toProto();\n        }\n        else if (this._queryOptions.fieldFilters.length > 1) {\n            const filters = [];\n            for (const fieldFilter of this._queryOptions.fieldFilters) {\n                filters.push(fieldFilter.toProto());\n            }\n            structuredQuery.where = {\n                compositeFilter: {\n                    op: 'AND',\n                    filters,\n                },\n            };\n        }\n        if (this._queryOptions.limitType === LimitType.Last) {\n            if (!this._queryOptions.hasFieldOrders()) {\n                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n            }\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n                // Flip the orderBy directions since we want the last results\n                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n                return new FieldOrder(order.field, dir).toProto();\n            });\n            // Swap the cursors to match the now-flipped query ordering.\n            structuredQuery.startAt = this._queryOptions.endAt\n                ? this.toCursor({\n                    values: this._queryOptions.endAt.values,\n                    before: !this._queryOptions.endAt.before,\n                })\n                : undefined;\n            structuredQuery.endAt = this._queryOptions.startAt\n                ? this.toCursor({\n                    values: this._queryOptions.startAt.values,\n                    before: !this._queryOptions.startAt.before,\n                })\n                : undefined;\n        }\n        else {\n            if (this._queryOptions.hasFieldOrders()) {\n                structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n            }\n            structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n            structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n        }\n        if (this._queryOptions.limit) {\n            structuredQuery.limit = { value: this._queryOptions.limit };\n        }\n        structuredQuery.offset = this._queryOptions.offset;\n        structuredQuery.select = this._queryOptions.projection;\n        reqOpts.transaction = transactionId;\n        return reqOpts;\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * @param transactionId A transaction ID.\n     * @private\n     * @returns A stream of document results.\n     */\n    _stream(transactionId) {\n        const tag = util_1.requestTag();\n        const self = this;\n        const stream = through2.obj(function (proto, enc, callback) {\n            const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n            if (proto.document) {\n                const document = self.firestore.snapshot_(proto.document, proto.readTime);\n                const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(self._queryOptions.converter));\n                // Recreate the QueryDocumentSnapshot with the DocumentReference\n                // containing the original converter.\n                finalDoc.fieldsProto = document._fieldsProto;\n                finalDoc.readTime = document.readTime;\n                finalDoc.createTime = document.createTime;\n                finalDoc.updateTime = document.updateTime;\n                this.push({ document: finalDoc.build(), readTime });\n            }\n            else {\n                this.push({ readTime });\n            }\n            callback();\n        });\n        this.firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            const request = this.toProto(transactionId);\n            return this._firestore.requestStream('runQuery', request, tag);\n        })\n            .then(backendStream => {\n            backendStream.on('error', err => {\n                logger_1.logger('Query._stream', tag, 'Query failed with stream error:', err);\n                stream.destroy(err);\n            });\n            backendStream.resume();\n            backendStream.pipe(stream);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n    /**\n     * Attaches a listener for QuerySnapshot events.\n     *\n     * @param {querySnapshotCallback} onNext A callback to be called every time\n     * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n     * @param {errorCallback=} onError A callback to be called if the listen\n     * fails or is cancelled. No further callbacks will occur.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    onSnapshot(onNext, onError) {\n        validate_1.validateFunction('onNext', onNext);\n        validate_1.validateFunction('onError', onError, { optional: true });\n        const watch = new watch_1.QueryWatch(this.firestore, this, this._queryOptions.converter);\n        return watch.onSnapshot((readTime, size, docs, changes) => {\n            onNext(new QuerySnapshot(this, readTime, size, docs, changes));\n        }, onError || console.error);\n    }\n    /**\n     * Returns a function that can be used to sort QueryDocumentSnapshots\n     * according to the sort criteria of this query.\n     *\n     * @private\n     */\n    comparator() {\n        return (doc1, doc2) => {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = this._queryOptions.hasFieldOrders()\n                ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction\n                : 'ASCENDING';\n            const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n            for (const orderBy of orderBys) {\n                let comp;\n                if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n                    comp = doc1.ref._path.compareTo(doc2.ref._path);\n                }\n                else {\n                    const v1 = doc1.protoField(orderBy.field);\n                    const v2 = doc2.protoField(orderBy.field);\n                    if (v1 === undefined || v2 === undefined) {\n                        throw new Error('Trying to compare documents on fields that ' +\n                            \"don't exist. Please include the fields you are ordering on \" +\n                            'in your select() call.');\n                    }\n                    comp = order_1.compare(v1, v2);\n                }\n                if (comp !== 0) {\n                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n                    return direction * comp;\n                }\n            }\n            return 0;\n        };\n    }\n    /**\n     * Applies a custom data converter to this Query, allowing you to use your\n     * own custom model objects with Firestore. When you call get() on the\n     * returned Query, the provided converter will convert between Firestore\n     * data and your custom type U.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * @example\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     data: FirebaseFirestore.DocumentData\n     *   ): Post {\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * @param converter Converts objects to and from Firestore.\n     * @return A Query<U> that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new Query(this.firestore, this._queryOptions.withConverter(converter));\n    }\n}\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class\n * @extends Query\n */\nclass CollectionReference extends Query {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     * @param path The Path of this collection.\n     */\n    constructor(firestore, path, converter) {\n        super(firestore, QueryOptions.forCollectionQuery(path, converter));\n    }\n    /**\n     * Returns a resource path for this collection.\n     * @private\n     */\n    get resourcePath() {\n        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    }\n    /**\n     * The last path element of the referenced collection.\n     *\n     * @type {string}\n     * @name CollectionReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`ID of the subcollection: ${collectionRef.id}`);\n     */\n    get id() {\n        return this._queryOptions.collectionId;\n    }\n    /**\n     * A reference to the containing Document if this is a subcollection, else\n     * null.\n     *\n     * @type {DocumentReference}\n     * @name CollectionReference#parent\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * let documentRef = collectionRef.parent;\n     * console.log(`Parent name: ${documentRef.path}`);\n     */\n    get parent() {\n        return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name CollectionReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`Path of the subcollection: ${collectionRef.path}`);\n     */\n    get path() {\n        return this.resourcePath.relativeName;\n    }\n    /**\n     * Retrieves the list of documents in this collection.\n     *\n     * The document references returned may include references to \"missing\n     * documents\", i.e. document locations that have no document present but\n     * which contain subcollections with documents. Attempting to read such a\n     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n     * `DocumentSnapshot` whose `.exists` property is false.\n     *\n     * @return {Promise<DocumentReference[]>} The list of documents in this\n     * collection.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * return collectionRef.listDocuments().then(documentRefs => {\n     *    return firestore.getAll(documentRefs);\n     * }).then(documentSnapshots => {\n     *    for (let documentSnapshot of documentSnapshots) {\n     *       if (documentSnapshot.exists) {\n     *         console.log(`Found document with data: ${documentSnapshot.id}`);\n     *       } else {\n     *         console.log(`Found missing document: ${documentSnapshot.id}`);\n     *       }\n     *    }\n     * });\n     */\n    listDocuments() {\n        const tag = util_1.requestTag();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId);\n            const request = {\n                parent: parentPath.formattedName,\n                collectionId: this.id,\n                showMissing: true,\n                // Setting `pageSize` to the maximum allowed value lets the backend cap\n                // the page size (currently to 300).\n                pageSize: Math.pow(2, 32) - 1,\n                mask: { fieldPaths: [] },\n            };\n            return this.firestore\n                .request('listDocuments', request, tag)\n                .then(documents => {\n                // Note that the backend already orders these documents by name,\n                // so we do not need to manually sort them.\n                return documents.map(doc => {\n                    const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n                    return this.doc(path.id);\n                });\n            });\n        });\n    }\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path. If no path is specified, an\n     * automatically-generated unique ID will be used for the returned\n     * DocumentReference.\n     *\n     * @param {string=} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The `DocumentReference`\n     * instance.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRefWithName = collectionRef.doc('doc');\n     * let documentRefWithAutoId = collectionRef.doc();\n     * console.log(`Reference with name: ${documentRefWithName.path}`);\n     * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n     */\n    doc(documentPath) {\n        if (arguments.length === 0) {\n            documentPath = util_1.autoId();\n        }\n        else {\n            path_1.validateResourcePath('documentPath', documentPath);\n        }\n        const path = this.resourcePath.append(documentPath);\n        if (!path.isDocument) {\n            throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n        }\n        return new DocumentReference(this.firestore, path, this._queryOptions.converter);\n    }\n    /**\n     * Add a new document to this collection with the specified data, assigning\n     * it a document ID automatically.\n     *\n     * @param {DocumentData} data An Object containing the data for the new\n     * document.\n     * @returns {Promise.<DocumentReference>} A Promise resolved with a\n     * [DocumentReference]{@link DocumentReference} pointing to the\n     * newly created document.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name: ${documentReference.id}`);\n     * });\n     */\n    add(data) {\n        const firestoreData = this._queryOptions.converter.toFirestore(data);\n        write_batch_1.validateDocumentData('data', firestoreData, /*allowDeletes=*/ false);\n        const documentRef = this.doc();\n        return documentRef.create(data).then(() => documentRef);\n    }\n    /**\n     * Returns true if this `CollectionReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `CollectionReference` is equal to the\n     * provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof CollectionReference && super.isEqual(other)));\n    }\n    /**\n     * Applies a custom data converter to this CollectionReference, allowing you\n     * to use your own custom model objects with Firestore. When you call add()\n     * on the returned CollectionReference instance, the provided converter will\n     * convert between Firestore data and your custom type U.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * @example\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     data: FirebaseFirestore.DocumentData\n     *   ): Post {\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * @param converter Converts objects to and from Firestore.\n     * @return A CollectionReference<U> that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, this.resourcePath, converter);\n    }\n}\nexports.CollectionReference = CollectionReference;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOrder(arg, op) {\n    // For backwards compatibility, we support both lower and uppercase values.\n    op = typeof op === 'string' ? op.toLowerCase() : op;\n    validate_1.validateEnumValue(arg, op, Object.keys(directionOperators), { optional: true });\n    return op;\n}\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOperator(arg, op, fieldValue) {\n    // For backwards compatibility, we support both `=` and `==` for \"equals\".\n    op = op === '=' ? '==' : op;\n    validate_1.validateEnumValue(arg, op, Object.keys(comparisonOperators));\n    if (typeof fieldValue === 'number' && isNaN(fieldValue) && op !== '==') {\n        throw new Error('Invalid query. You can only perform equals comparisons on NaN.');\n    }\n    if (fieldValue === null && op !== '==') {\n        throw new Error('Invalid query. You can only perform equals comparisons on Null.');\n    }\n    return op;\n}\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n */\nfunction validateDocumentReference(arg, value) {\n    if (!(value instanceof DocumentReference)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentReference'));\n    }\n}\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n */\nfunction validateQueryValue(arg, value) {\n    serializer_1.validateUserInput(arg, value, 'query constraint', {\n        allowDeletes: 'none',\n        allowTransforms: false,\n    });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\nfunction isArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (!left[i].isEqual(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n */\nfunction coalesce(...values) {\n    return values.find(value => value !== undefined);\n}\n//# sourceMappingURL=reference.js.map"]},"metadata":{},"sourceType":"script"}